
; ranks are 2-14 with 2 being two, 13 being king, and 14 being ace
; suits are 1-4 with no particular labelling
; takes a list of cards (rank . suit) and returns the value of the best poker 
; hand which can be made with them
; doesn't work for ten or more cards if there are multiple flushes
; all sorting is done highest to lowest
(
    (defun hand_compare (a b)
        (if (= (f a) (f b))
            (if (r a)
                (hand_compare (r a) (r b))
                0
            )
            (- (* 2 (> (f a) (f b))) 1)
        )
    )

    (defun hand< (a b)
        (= (hand_compare a b) -1)
    )

    (defun merge (a b)
        (if (not a)
            b
            (if (not b)
                a
                (if (> (f a) (f b))
                    (c (f a) (merge (r a) b))
                    (c (f b) (merge a (r b)))
                )
            )
        )
    )

    ; Sorts atoms into descending order
    ; This is optimized for sorting short lists
    ; A more general function would return a list of lists of ascending sizes 
    ; to be merged 
    (defun atomsort ((@ firstpos (first @ secondpos (second @ thirdpos (third . remaining)))))
        (if firstpos
            (if secondpos
                (if thirdpos
                    (assign-lambda
                        mylist
                        (if (> first second)
                            (if (> second third)
                                (list first second third)
                                (if (> first third)
                                    (list first third second)
                                    (list third first second)
                                )
                            )
                            (if (> first third)
                                (list second first third)
                                (if (> second third)
                                    (list second third first)
                                    (list third second first)
                                )
                            )
                        )
                        (merge mylist (atomsort remaining))
                    )
                    (if (> first second)
                        firstpos
                        (list second first)
                    )
                )
                firstpos
            )
            0
        )
    )

    (defun find_flush (suits)
        (assign 
            ((count1 . suit1)) (group_by_count_clean (atomsort suits))
            (if (< 5 count1)
                0
                suit1
            )
        )
    )

    (defun straight_high_inner (ranks last count)
        (if (not ranks)
            (if (logand (= last 2) (= count 4))
                ; maybe ace to five
                5
                0
            )
            (if (= last (f ranks))
                ; skip identical cards
                (straight_high_inner (r ranks) last count)
                ; if the partial straight continues
                (if (= (f ranks) (- last 1))
                    (if (= count 4)
                        ; found a straight, add 3 to last because next and last are included
                        (+ last 3)
                        ; keep looking for a straight with the count going up by one
                        (straight_high_inner (r ranks) (f ranks) (+ count 1))
                    )
                    ; reset the count
                    (straight_high_inner (r ranks) (f ranks) 1)
                )
            )
        )
    )

    ; returns the high card of a straight or 0 if there isn't any
    ; ranks must be sorted in descending order
    (defun straight_high (ranks)
        (assign high (straight_high_inner ranks 0 0)
            (if (= high 5)
                (* (= (f ranks) 14) 5)
                high
            )
        )
    )

    (defun group_by_count_inner (items last count)
        (if (not items)
            (list (logior (lsh count 4) last))
            (if (= (f items) last)
                (group_by_count_inner (r items) last (+ count 1))
                (assign-inline val (group_by_count_inner (r items) (f items) 1)
                    (c (logior (lsh count 4) last) val)
                )
            )
        )
    )

    (defun group_by_count_clean (items)
        (map
            (lambda (x) (c (lsh x -4) (& x 15)))
            (group_by_count_inner items (f items) 0)
        )
    )

    (defun find_straight_flush_indices (flush_suit straight_flush_high cards)
        (find_straight_indices straight_flush_high 
            (map (lambda (@ card (rank . suit)) (if (= suit flush_suit) card (c 0 0))) cards))
    )

    (defun flush_cards_with_index (flush_suit index (@ cards ((first_rank . first_suit))))
        (if (not cards)
            0
            (if (= flush_suit first_suit)
                (c (logior (lsh first_rank 4) index) (flush_cards_with_index flush_suit (+ index 1) (r cards)))
                (flush_cards_with_index flush_suit (+ index 1) (r cards))
            )
        )
    )

    (defun find_flush_indices (flush_suit cards)
        myfiltered (truncate 5 (atomsort (flush_cards_with_index flush_suit 0 cards)))
        (to_bitfield 0 (reverse (atomsort (map (lambda (x) (logand x 15)) myfiltered))))
    )

    ; includes should be in ascending order
    (defun to_bitfield (index includes)
        (if (not includes)
            0
            (if (= index (f includes))
                (logior 1 (lsh 1 (to_bitfield (+ index 1) (r includes))))
                (lsh 1 (to_bitfield (+ index 1) includes))
            )
        )
    )

    (defun find_straight_includes (ranks with_index)
        (if (= (f ranks)) (lsh -4 (f with_index))
            (logior (logand 15 (f with_index)) (lsh 1 (find_straight_includes (r ranks) (r with_index))))
            (lsh 1 (find_straight_includes ranks (r with_index)))
        )
    )

    (defun find_straight_indices (my_straight_high cards)
        (assign
            with_index (atomsort (label_rank_indices 0 cards))
            my_ranks (if (= my_straight_high 5) (list 14 5 4 3 2) 
                (list my_straight_high (- my_straight_high 1) (- my_straight_high 2) 
                (- my_straight_high 3) (- my_straight_high 4)))
            includes (reverse (atomsort (find_straight_includes my_ranks with_index)))
            (to_bitfield 0 includes)
        )
    )

    (defun find_single_indices (count rank cards)
        (if (logior (not cards) (not count))
            0
            (logior (= rank (f cards)) (lsh 1 (find_single_indices (- count 1) (r cards))))
        )
    )

    (defun find_hand_indices ((@ hand ((firstcount . firstrank))) cards)
        (if (not hand)
            0
            (logior (find_hand_indices (r hand) cards) (find_single_indices firstcount firstrank cards))
        )
    )

    (defun crop_hand (leftover ((firstcount . firstrank) @ remaining))
        (if (firstcount >= leftover)
            (c leftover 0)
            (c firstcount (crop_hand (- leftover firstcount) remaining))
        )
    )

    (defun handcalc (cards)
        (assign
            first (lambda (x) (f x))
            sorted_ranks (atomsort (map first cards))
            hand (crop_hand 5 (group_by_count_clean sorted_ranks))
            ((firstcount . firstrank) (secondcount . secondrank)) hand
            flush_suit (find_flush (map cards rest))
            (if flush_suit
                (assign 
                    flush_cards (filtermap (lambda ((& flush_suit) rank . suit) (if (= suit flush_suit) rank 0)))
                    straight_flush_high (straight_high (atomsort flush_cards))
                    (if straight_flush_high
                        (find_straight_flush_indices flush_suit straight_flush_high cards)
                        (if (logior (< firstcount 3) (logand (= firstcount 3) (= secondcount 1)))
                            (find_flush_indices flush_suit cards)
                            (find_hand_indices hand cards)
                        )
                    )
                )
                (assign 
                    my_straight_high (straight_high sorted_ranks)
                    (if (logand my_straight_high (logior (< firstcount 3) (logand (= firstcount 3) (= secondcount 1))))
                        (find_straight_indices my_straight_high cards)
                        (find_hand_indices hand cards)
                    )
                )
            )
        )
    )
)
