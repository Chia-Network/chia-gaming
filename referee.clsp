
; Adjudicates a two player turn based game
; MOVE, VALIDATION_HASH and MOVER_SHARE were all accepted optimistically from the last move
; Both VALIDATION_HASH values are a sha256 of a validation program hash and the shatree of a state
; The next validation program hash may be nil which means no futher moves are allowed
; MOVER_SHARE is how much the mover will get if they fold/accept
; MOD_HASH should be the shatree of referee itself
; If action is timeout args is nil
; If action is accuse args is (state validation_program mover_puzzle solution evidence)
; If action is move args is (new_move new_validation_info_hash new_mover_share mover_puzzle solution)
; validation programs get passed this:
; ((MOVE NEXT_VALIDATION_HASH MOVER_SHARE PREVIOUS_VALIDATION_HASH MOVER_PUZZLE_HASH WAITER_PUZZLE_HASH
;        AMOUNT TIMEOUT MAX_MOVE_SIZE REFEREE_HASH)
;        state me mover_puzzle solution . evidence)
(mod (@ all_args ((MOVE VALIDATION_PROGRAM_HASH MOVER_SHARE PREVIOUS_VALIDATION_PROGRAM_HASH 
        MOVER_PUZZLE_HASH WAITER_PUZZLE_HASH 
        @ constants (AMOUNT TIMEOUT MAX_MOVE_SIZE MOD_HASH)) . args))
    (include *standard-cl-22*)
    ; This should be a bulk import from a standard library
    (include assert.clinc)
    (include curry.clinc)
    (include match.clinc)
    (include shatree.clinc)
    (include prefix.clinc)
    (include condition_codes.clinc)

    (defun <= (A B) (not (> A B)))
    (defun >= (A B) (not (> B A)))
    (defun concat (A B) 
        (if A 
            (c (f A) (concat (r A) B)) 
            B
        )
    )

    (if (not args)
        ; timeout
        (list
            (list ASSERT_SECONDS_RELATIVE TIMEOUT)
            (i MOVER_SHARE (list CREATE_COIN MOVER_PUZZLE_HASH MOVER_SHARE) (list 1))
            (i (- amount MOVER_SHARE) (list CREATE_COIN WAITER_PUZZLE_HASH (- amount MOVER_SHARE)) (list 1))
        )
        (l (r (r args)))
        ; accuse
        (assign
            (validation_program_args previous_validation_program mover_puzzle solution) args
            (assert
                (= MOVER_PUZZLE_HASH (shatree mover_puzzle))
                (= PREVIOUS_VALIDATION_INFO_HASH (sha256 (shatree previous_validation_program) (shatree 
                        validation_program_args)))
                ; usually returns the conditions verbatim
                (concat (a previous_validation_program all_args)
                        (a mover_puzzle solution))
            )
        )
        ; move
        (assign 
            (new_move new_validation_info_hash new_mover_share mover_puzzle solution) args
            new_puzzle_hash (curry_hashes MOD_HASH (shatree (list
                    new_move new_validation_info_hash new_mover_share
                    VALIDATION_INFO_HASH WAITER_PUZZLE_HASH MOVER_PUZZLE_HASH &rest constants)))
            conditions (a mover_puzzle solution)
            (assert
                ; When VALIDATION_INFO_HASH is nil no further moves are allowed
                VALIDATION_INFO_HASH
                (<= (strlen new_move) MAX_MOVE_SIZE)
                (<= new_mover_share AMOUNT)
                (>= new_mover_share 0)
                (logior (not new_validation_info_hash) (= 32 (strlen new_validation_info_hash)))
                (= MOVER_PUZZLE_HASH (shatree mover_puzzle))
                ; Check that the child output is made
                (match
                    (lambda ((& new_puzzle_hash AMOUNT) (condname arg1 arg2))
                        (logand (= condname CREATE_COIN) (= arg1 new_puzzle_hash) (= arg2 AMOUNT))
                    )
                    conditions
                )
                conditions
            )
        )
    )
)
