(
; play_template is (first_player_driver second_player_driver whether_paired required_size_factor 
;       initial_max_move_size initial_validator_program_hash initial_state initial_mover_share)
; Driver functions are either moving or waiting type
; Moving driver takes (readable_move amount old_state entropy) and returns
;       (move validation_program_hash new_state max_move_size mover_share waiting_driver message_parser)
; Waiting driver takes (amount old_state move max_move_size mover_share) and returns
;       (MAKE_MOVE readable_info validation_program_hash new_state moving_driver message) or 
;       (SLASH evidence)
; Message parsers take (message state amount) and return readable_info
; returns [(puzzle_hash amount first_coin_handler second_coin_handler)]
(defun make_coin_handlers (play_template player_contribution
        timeout player_one_puzzle_hash player_two_puzzle_hash nonce)
)

; exactly one of these values is non-nil
; if spend_conditions has a value returns (readable new_coin_handler message coin_solution agg_sig) with
; everything after new_coin_handler optional. Message is only sometimes used and coin_solution is 
; mostly for immediate slashing
; if readable_move has a value returns (puzzle_reveal coin_solution agg_sig)
; if message is non-nil returns readable
; if timeout_hit is non-nil returns nil or (puzzle_reveal coin_solution agg_sig)
; my_solution_maker takes a shatree value of conditions and returns (solution aggsig)
(defun coin_handler (my_inner_puzzle my_inner_solution_maker spend_conditions readable_move message timeout_hit)
)
)
