
; Higher layer needs to use handshake message in a secure order
; Higher layer is cognizant of who has the potato, out of game balances, and 
; (id, amount, turn) for games in progress as well as having UX for them. It's responsible for 
; queueing up actions until after we have the potato
; Higher layer is also responsible for making sure there's a meeting of the minds before attempting to 
; start a game and checking that the game start attempt is one that it already agreed to.
;
; ChannelHandler()
; to handshake Alice and Bob agree on parameters, then exchange pubkeys, then exchange initial unrolls, 
; and finally trade an offer and acceptance of creating the state channel
;
; (my_state_coin_pubkey, my_unroll_coin_pubkey, my_referee_puzzle_hash) get_pubkeys()
;
; (initial_puzzle_hash, my_initial_channel_half_signature) initiate(launcher_coin_id, whether_we_start, 
;       their_state_pubkey, their_unroll_pubkey, their_referee_puzzle_hash, my_contribution, 
;       their_contribution) throws error
;
; void finish_handshake(their_initial_channel_half_signature) throws error
;
; (my_channel_half_signature, my_unroll_half_signature) send_potato_nil()
;
; void received_potato_nil(their_channel_half_signature, their_unroll_half_signature) throws error
;
; (my_channel_half_signature, their_unroll_half_signature) send_potato_start_game(my_contribution,
;       their_contribution, [(id, amount, game_handler, is_my_turn, timeout, initial_validation_puzzle, 
;       initial_validation_puzzle_hash, initial_state, initial_move, initial_max_move_size, initial_mover_share)])
;
; void received_potato_start_game(their_channel_half_signature, their_unroll_half_signature, [(id, amount, 
;       game_handler, is_my_turn, timeout, initial_validation_puzzle, initial_validation_puzzle_hash, 
;       initial_state, initial_move, initial_max_move_size, initial_mover_share)]) throws error
;
; (their_channel_half_signature, their_unroll_half_signature, move, validation_info_hash, max_move_size, 
;       mover_share) send_potato_move(id, readable_move)
;
; (readable_move, message) received_potato_move(their_channel_half_signature, their_unroll_half_signature,
;       id, move, validation_info_hash, max_move_size, mover_share) throws error
;
; readable_move received_message(id, message) throws error
;
; (my_channel_half_signature, my_unroll_half_signature, my_share) send_potato_accept(id)
;
; my_share received_potato_accept(their_channel_half_signature, their_unroll_half_signature, id) throws error
;
; (channel_puzzle_reveal, solution, my_half_signature) send_potato_clean_shutdown(conditions) 
;
; (channel_puzzle_reveal, solution, aggsig) received_potato_clean_shutdown(their_channel_half_signature, 
;       conditions) throws error
;
; (channel_puzzle, solution, aggsig) get_unroll_spend()
;
; (unroll_coin_id, puzzle_reveal, solution, aggsig, whether_has_timeout) state_channel_spent(conditions) throws error
;
; (my_clean_reward_id, [(id, coin_id, referee)], id_of_cancelled_game, id_to_move_play, 
;       id_of_accept_game) unroll_coin_spent(conditions) throws error
;
; (shared_puzzle_reveal, [(coinid, solution)], aggsig, result_coin_id) spend_reward_coins([coinid], target_puzzle_hash)

; ChannelHandler fields
; state channel coin id
; {id: (puzzle_hash, amount, referee)}
; my out of game balance
; opponent out of game balance
; my channel coin private key
; my unroll coin private key
; my referee private key
; opponent channel coin public key
; opponent unroll coin public key
; opponent referee puzzle hash
; whether I have the potato
; current state number
; last state channel aggsig
; last unroll aggsig
; id of game of move I just made (nil if I have potato)
; id of game I just made (nil if I have potato)
; id of game I just accepted (nil if I have potato)
; referee of game I just accepted (nil if I have potato)
; last nonce number


; RefereeHandler(amount, game_handler, is_my_turn, timeout, validation_puzzle, validation_puzzle_hash, 
;       initial_state, initial_move, initial_max_move_size, initial_mover_share, local_initiate, 
;       my_private_key, their_puzzle_hash, nonce)
;
; puzzle_hash get_initial_puzzle_hash()
; 
; (puzzle_hash, move, validation_info_hash, max_move_size, mover_share) my_turn_make_move(readable_move)
;
; called after my_turn_make_move() and reiterates what it was told
; (puzzle_reveal, solution, aggsig, new_coin_id) get_transaction_for_move(coinid)
;
; takes into account whose turn it is
; my_share get_my_share()
;
; takes into account whose turn it is
; (puzzle_reveal, solution, aggsig, my_reward_coin_id) get_timeout_transaction(coinid)
;
; ((MOVE, new_coin_id, readable) or (TIMEDOUT, my_reward_coin_id)) my_turn_coin_spent (coinid, conditions) throws error
;
; (puzzle_hash, readable_move, message) their_turn_move_off_chain (mave, validation_info_hash, max_move_size, 
;       mover_share) throws error
;
; ((TIMEDOUT, my_reward_coin_id) or (MOVED, new_coin_id, readable) or (SLASH, new_coin_id, puzzle_reveal, 
;       solution, aggsig, my_reward_coin_id)) their_turn_coin_spent(coinid, conditions) throws error
; 
; readable message_arrived(message) throws error


; My turn driver takes (readable_new_move amount last_state last_move last_mover_share entropy) and returns
;       (waiting_driver move validation_program validation_program_hash state max_move_size mover_share
;       message_parser)
; Message parser takes (message amount state move mover_share) and returns error or readable_info
;
; their turn driver takes (amount last_state last_move last_mover_share 
;       new_move new_validation_info_hash new_max_move_size new_mover_share) and returns
;       (MAKE_MOVE moving_driver readable_info message) or
;       (SLASH evidence aggsig)



; returns puzzle
(defun make_standard_puzzle (public_key))

; returns puzzle_hash
; equivalent to (shatree (standard_puzzle public_key)) but much more efficient
(defun make_standard_puzzle_hash (public_key))

; returns (solution aggsig)
(defun standard_solution (private_key coin_id conditions))

; returns (solution aggsig)
(defun standard_solution_partial (private_key coin_id conditions aggregate_public_key))

; returns signature
(defun unsafe_sign (private_key value))

; returns signature
(defun unsafe_sign_partial (private_key value aggregate_public_key))

; returns public_key
(defun private_to_public_key (mykey))

; returns public_key
(defun aggregate_public_keys (key1 key2))

; returns signature
(defun aggregate_signatures (signature_1 signature_2))
