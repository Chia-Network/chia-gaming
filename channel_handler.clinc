
; Higher layer needs to use handshake message in a secure order
; Higher layer is cognizant of who has the potato, out of game balances, and 
; (id, amount, turn) for games in progress as well as having UX for them. It's responsible for 
; queueing up actions until after we have the potato
; Higher layer is also responsible for making sure there's a meeting of the minds before attempting to 
; start a game and checking that the game start attempt is one that it already agreed to.
;
; make pubkeys
;       entropy
;       returns (my public key for state coin, my public key for unroll coin, my public key for referee and reward coins)
; get handshake info
;       entropy
;       Launcher coin id
;       whether we initiate
;       their pubkey for state coin
;       their pubkey for unroll coin
;       their pubkey for use in referee and reward coins
;       my contribution
;       their contribution
;       returns initial_puzzle_hash, initial_channel_half_signature
; make_state
;       entropy
;       Launcher coin id
;       whether we initiate
;       their pubkey for state coin
;       their pubkey for unroll coin
;       their pubkey for use in referee
;       my contribution
;       their contribution
;       their_initial_channel_half_signature
;       returns error or state
;
; send potato nil 
;       potato_state
;       returns (no_potato_state, channel_half_signature, unroll_half_signature)
; received potato nil
;       non_potato_state
;       state_channel_half_signature
;       unroll_half_signature
;       returns error or potato_state
; send potato move 
;       potato_state
;       id
;       readable_move 
;       returns (no_potato_state, channel_half_signature, unroll_half_signature, move, validation_info_hash,
;               max_move_size, mover_share)
; received potato with move
;       non_potato_state
;       state_channel_half_signature
;       unroll_half_signature
;       id 
;       move 
;       validation_info_hash 
;       max_move_size 
;       mover_share
;       returns error or (potato_state, readable, message)
; received message
;       non_potato_state
;       id
;       message
;       returns error or readable
; send potato accept
;       potato_state
;       id 
;       returns (no_potato_state, channel_half_signature, unroll_half_signature, my_share)
; received potato accept
;       non_potato_state
;       state_channel_half_signature
;       unroll_half_signature
;       id
;       returns error or (potato_state, my_share)
; send potato start game
;       potato_state
;       my contribution
;       their contribution
;       [(id, amount, game_handler, is_my_turn, timeout, initial_validation_puzzle, initial_validation_puzzle_hash, 
;               initial_state, inital_move, initial_max_move_size, initial_mover_share)]
;       returns (no_potato_state, channel_half_signature, unroll_half_signature)
; received potato start game
;       non_potato_state
;       state_channel_half_signature
;       unroll_half_signature
;       my contribution
;       their contribution
;       [(id, amount, game_handler, is_my_turn, timeout, initial_validation_puzzle, initial_validation_puzzle_hash, 
;               initial_state, inital_move, initial_max_move_size, initial_mover_share)]
;       returns error or (new_state)
; send potato clean shutdown
;       potato_state
;       conditions
;       returns channel_half_signature
; received potato clean shutdown
;       non_potato_state
;       conditions
;       state_channel_half_signature
;       returns error or (channel_puzzle_reveal, solution, aggsig)
;
;
; get unroll spend
;       state
;       returns (channel_puzzle, solution, aggsig)
; state channel coin spent
;       state
;       conditions
;       returns error or (unroll coin id, unroll coin puzzle reveal, solution, aggsig, whether has timeout)
; unroll coin spent
;       state
;       conditions
;       returns error or (my_clean_reward_id, [(id, coin_id, game_coin)], [cancelled_game_id])
; spend reward coins
;       [coinid]
;       target_puzzle_hash
;       returns (shared_puzzle_reveal [coinid solution] aggsig result_coin_id)

; Game coin calls
;
; make_move (my_turn_state readable) returns (their_turn_state puzzle_reveal solution aggsig new_coin_id)
; if an unexpected spend happens it can be compared to a timeout spend
; make_timeout_my_move (my_turn_state) returns (puzzle_reveal solution aggsig my_reward_coin_id)
;
; make_timeout_their_move (their_turn_state) returns (puzzle_reveal solution aggsig my_reward_coin_id)
; coin_spent_their_move (their_turn_state conditions) returns error or 
;       (MOVED new_state new_coin_id readable) or
;       (TIMEDOUT my_reward_coin_id) or 
;       (SLASH puzzle_reveal solution aggsig my_reward_coin_id)


; Potato State
; state channel coin id
; current state number
; current games: [(id puzzle_hash amount whether_my_move referee_maker)]
; my out of game balance
; opponent out of game balance
; my channel coin private key
; my unroll coin private key
; my referee private key
; opponent channel coin public key
; opponent unroll coin public key
; opponent referee public key
; entropy
; state channel aggregate pubkey
; Solution of state channel coin
; state channel coin aggregate signature
; Solution of unroll coin
; Signature of unroll of unroll coin

; Not Potato State
; current state number
; previous state
; my last move. Nil if just started game/sent potato
; game id just started. Only non-nil if we just made a game start
; current games: (id balance puzzle_hash amount coin_handler)
; my out of game balance
; opponent out of game balance



; referee factory takes (amount, game_handler, is_my_turn, timeout, validation puzzle, validation_puzzle_hash,
;       state, inital_move, max_move_size mover_share
;       local_initiate my_private_key their_puzzle_hash nonce) and returns (state, puzzle_hash)
; 
; my_turn_move_off_chain takes (my_turn_state readable_move entropy) and returns (their_turn_state 
;       move validation_info_hash max_move_size mover_share)
; my_turn_move_on_chain takes (my_turn_state coinid readable_move entropy) and returns (their_turn_state 
;       puzzle_reveal solution aggsig new_coin_id)
; my_turn_accept_off_chain takes (my_turn_state) and returns (my_share)
; my_turn_timeout_on_chain takes (my_turn_state coinid) and returns (puzzle_reveal solution aggsig my_reward_coin_id)
;
; their_turn_move_off_chain takes (their_turn_state move validation_info_hash 
;       max_move_size mover_share) and returns error or 
;       (my_turn_state readable_move message)
; their_turn_moved_on_chain takes (their_turn_state coinid conditions) and returns error or
;       (TIMEDOUT my_reward_coin_id) or
;       (MAKE_MOVE my_turn_state readable new_coin_id) or
;       (SLASH new_coin_id puzzle_reveal solution aggsig reward_coin_id)
; their_turn_off_chain_message_arrived takes (their_turn_state message) and returns error or readable
; their_turn_timeout_off_chain takes (their_turn_state) and returns (my_share)
; their_turn_timeout_on_chain takes (their_turn_state coinid) and returns (puzzle_reveal solution aggsig my_reward_coin_id)


; My turn driver takes (readable_new_move amount last_state last_move last_mover_share entropy) and returns
;       (waiting_driver move validation_program validation_program_hash state max_move_size mover_share
;       message_parser)
; Message parser takes (message amount state move mover_share) and returns error or readable_info
;
; their turn driver takes (amount last_state last_move last_mover_share 
;       new_move new_validation_info_hash new_max_move_size new_mover_share) and returns
;       (MAKE_MOVE moving_driver readable_info message) or
;       (SLASH evidence aggsig)



; returns puzzle
(defun make_standard_puzzle (public_key))

; returns puzzle_hash
; equivalent to (shatree (standard_puzzle public_key)) but much more efficient
(defun make_standard_puzzle_hash (public_key))

; returns (solution aggsig)
(defun standard_solution (private_key coin_id conditions))

; returns (solution aggsig)
(defun standard_solution_partial (private_key coin_id conditions aggregate_public_key))

; returns signature
(defun unsafe_sign (private_key value))

; returns signature
(defun unsafe_sign_partial (private_key value aggregate_public_key))

; returns public_key
(defun private_to_public_key (mykey))

; returns public_key
(defun aggregate_public_keys (key1 key2))

; returns signature
(defun aggregate_signatures (signature_1 signature_2))
