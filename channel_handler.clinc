
; Higher layer is cognizant of who has the potato, out of game balances, and 
; (id, amount, turn) for games in progress as well as having UX for them. It's responsible for 
; queueing up actions until after we have the potato
; Higher layer is also responsible for making sure there's a meeting of the minds before attempting to 
; start a game and checking that the game start attempt is one that it already agreed to.
;
; make pubkeys
;       entropy
;       returns (my public key for state coin, my public key for unroll coin, my public key for referees)
; get handshake info
;       entropy
;       Launcher coin id
;       whether we initiate
;       My puzzle hash for rewards
;       their pubkey for state coin
;       their pubkey for unroll coin
;       their pubkey for use in referee
;       their puzzle hash for rewards
;       my contribution
;       their contribution
;       returns puzzle_hash, initial_channel_half_signature
; make_state
;       entropy
;       Launcher coin id
;       whether we initiate
;       My puzzle hash for rewards
;       their pubkey for state coin
;       their pubkey for unroll coin
;       their pubkey for use in referee
;       their puzzle hash for rewards
;       my contribution
;       their contribution
;       their_initial_channel_half_signature
;       returns error or state
;
; received potato vanilla
;       non_potato_state
;       new_puzzle_hash
;       state_channel_half_signature
;       unroll_half_signature
;       returns error or potato_state
; received potato with move
;       non_potato_state
;       new puzzle hash
;       state_channel_half_signature
;       unroll_half_signature
;       id 
;       move
;       returns error or (potato_state, readable)
; received potato with accept
;       non_potato_state
;       new puzzle hash
;       state_channel_half_signature
;       unroll_half_signature
;       id
;       returns error or (potato_state, my_share)
; received potato with game addition
;       non_potato_state
;       new puzzle hash
;       state_channel_half_signature
;       unroll_half_signature
;       contribution
;       game_info
;       returns error or ([id], new state)
; received potato clean shutdown
;       non_potato_state
;       state_channel_half_signature
;       returns error or (channel puzzle reveal, solution, aggsig)
; received message from peer
;       non_potato_state
;       id
;       message
;       returns error or readable
;
; send potato start game
;       potato_state
;       contribution
;       game_info
;       returns (no_potato_state, new_puzzle_hash, channel_half_signature, unroll_half_signature, [id])
; send potato move 
;       potato_state
;       id
;       readable_move
;       returns (no_potato_state, new_puzzle_hash, channel_half_signature, unroll_half_signature, move)
; send potato accept
;       potato_state
;       id 
;       returns (no_potato_state, new_puzzle_hash, channel_half_signature, unroll_half_signature, split)
; send potato nil 
;       potato_state
;       returns (no_potato_state, new_puzzle_hash, channel_half_signature, unroll_half_signature)
; send potato clean shutdown
;       potato_state
;       returns channel_half_signature
;
; start unroll
;       state
;       returns (channel_puzzle, solution, aggsig)
; state channel coin spent
;       state
;       conditions
;       returns error or (unroll coin id, unroll coin puzzle reveal, solution, aggsig, whether has timeout)
; unroll coin spent
;       state
;       conditions
;       returns error or (my_clean_balance, their_clean_balance, [(id, coin_id, game_coin)], [cancelled_game_id])

; Game info format
; higher layer is assumed to have confirmed agreement on everything after handlers
; (initial_mover_handler initial_waiter_handler whether_makes_pair required_size_factor
; initial_max_move_size initial_validator initial_validator_hash 
; initial_state initial_mover_share_proportion)

; Game coin calls
;
; make move (my_turn_state readable) returns (new_state puzzle_reveal solution aggsig new_coin_id)
; make_timeout_my_move (my_turn_state) returns (puzzle_reveal solution aggsig my_balance 
;       payback_puzzle_reveal solution aggsig)
;
; coin spent (their_turn_state conditions) returns error or 
;       (MOVED new_state new_coin_id readable) or
;       (TIMEDOUT my_share) or 
;       (SLASH new_coin_id puzzle_reveal solution aggsig)
; make_timeout_their_move (their_turn_state) returns (puzzle_reveal solution aggsig 
;       my_balance payback_puzzle_reveal solution aggsig)


; Potato State
; state channel coin id
; current state number
; current games: (id puzzle_hash amount coin_handler)
; my out of game balance
; opponent out of game balance
; my channel coin private key
; my unroll coin private key
; my referee private key
; my reward puzzle hash
; opponent channel coin public key
; opponent unroll coin public key
; opponent referee public key
; opponent reward puzzle hash
; entropy
; Solution of state channel coin
; Signature of unroll of state channel coin
; Solution of unroll coin
; Signature of unroll of unroll coin

; Not Potato State
; current state number
; previous state
; my last move. Nil if just started game/sent potato
; game id just started. Only non-nil if we just made a game start
; current games: (id balance puzzle_hash amount coin_handler)
; my out of game balance
; opponent out of game balance




; referee factory takes (amount game_info local_initiate timeout my_private_key 
;       their_puzzle_hash nonce) and returns 
;       [(amount, referee_maker, is_my_turn, puzzle_hash)]
; 
; my turn referee maker off chain takes (readable_move entropy) and returns (their_turn_referee_maker 
;       puzzle_hash move validation_info_hash max_move_size mover_share message_parser)
; accepter off chain takes () and returns (my_share)
; my turn referee maker on chain takes takes (readable_move coinid entropy) and returns (their_turn_referee_maker 
;       puzzle_reveal solution aggsig new_puzzle_hash)
; make timeout on chain takes () and returns (puzzle_reveal solution aggsig my_share)
;
; their turn referee maker off chain takes (puzzle_hash move validation_info_hash 
;       max_move_size mover_share) and returns error or 
;       (my_turn_referee_maker readable_move)
; their turn timeout off chain takes (my_share) and returns error or nil
; their turn referee maker on chain takes (coinid conditions) and returns error or
;       (TIMEDOUT my_share) or
;       (MAKE_MOVE my_turn_referee_maker readable puzzle_hash message) or
;       (SLASH puzzle_reveal solution aggsig)
; their turn make timeout on chain takes () and returns (puzzle_reveal solution aggsig my_share)


; game factory takes (amount game_info local_initiate) and returns [(amount, driver, is_my_turn, 
;       validation_program, state, max_move_size, mover_share)]
; My turn driver takes (readable_move entropy) and returns
;       (waiting_driver move validation_program state max_move_size mover_share
;       message_parser)
; Message parser takes (message) and returns readable_info
;
; their turn driver takes (move validation_info_hash max_move_size mover_share) and returns
;       (MAKE_MOVE moving_driver readable_info message) or
;       (SLASH evidence aggsig)



; returns puzzle
(defun make_standard_puzzle (public_key))

; returns puzzle_hash
; equivalent to (shatree (standard_puzzle public_key)) but much more efficient
(defun make_standard_puzzle_hash (public_key))

; returns (solution aggsig)
(defun standard_solution (private_key coin_id conditions))

; returns (solution aggsig)
(defun standard_solution_partial (private_key coin_id conditions aggregate_public_key))

; returns signature
(defun unsafe_sign (private_key value))

; returns signature
(defun unsafe_sign_partial (private_key value aggregate_public_key))

; returns public_key
(defun private_to_public_key (mykey))

; returns public_key
(defun aggregate_public_keys (key1 key2))

; returns signature
(defun aggregate_signatures (signature_1 signature_2))
