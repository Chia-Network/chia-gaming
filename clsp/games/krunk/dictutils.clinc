; 0x80000000
; 0x7fffffff
(import std.li)
(import std.len)
;(import std.sig)
(import std.slice)
(import std.truncate)
;(import std.is_there)

; TODO: implement `sig`
(defun sig (data)
    (concat "signature" data)
)

(defun check_sig (data data_sig)
    (assert (= data_sig (sig data)))
)

; Words is a list of 5 letter words in sorted order all low caps
; creates a BLS private key which it then destroys
; returns a balanced tree of nodes which are either (leftnode word rightnode) or (minboundary maxboundary signature)
; also return the generated public key
; we are using entropy as the private key
(defun create_dictionary (words private_key)
    ; (len words) -
    (assign
        public_key (pubkey_for_exp private_key)
        ; TODO: find midpoint word

        dictionary (create_dictionary_inner (0x80000000 0x7fffffff (len words) words private_key))
        (li dictionary public_key)
    )
)

; TODO: verify list is sorted
; "upper" means "higher in value" when regarded as a byte-string here (using <str).
(defun create_dictionary_inner (lower upper words_len words private_key)
    (if (not words)
        (if (< upper lower)
            0
            (li (concat lower upper) (sig (concat lower upper) private_key))
        )
        (assign
            middle_pos (/ len 2)
            (mid_word . upper_words) (slice words middle_pos)
            (li
                (create_dictionary_inner lower (- mid_word 1) middle_pos words private_key)
                mid_word
                (create_dictionary_inner (+ mid_word 1) upper (- words_len (+ middle_pos 1)) upper_words private_key)
            )
        )
    )
)

; returns a signature
;(defun find_sig (min_boundary max_boundary private_key)
;    (sign (concat min_boundary max_boundary) private_key)
;)

; returns nil if word is in dictionary otherwise.
; arguments are (minboundary maxboundary signature)
(defun find_exclusion_proof (word (@ node (left_node old_word right_node)))
    ;; (if (not (is_there right_node))
    (if (not (= (len node) 3))
        node
        (= word old_word)
        0
        (find_exclusion_proof word (if (< word old_word) left_node right_node))
    )
)

(export create_dictionary)
(export find_exclusion_proof)
(export create_dictionary_inner)
