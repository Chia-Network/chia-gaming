(export krunk_factory)
(import onchain.krunk.commit exposing commit_validate commit_validate_hash)
(import std.assert)
(import std.shatree)
(import std.curry)

; game factory takes (alice_contribution bob_contribution) and returns
; (initial_mover_handler initial_waiter_handler
; initial_max_move_size initial_state initial_mover_share
; (validator_hash validator validator_hash validator ...) first one is initial)
(defun krunk_factory (alice_contribution bob_contribution)
    (assert
        (= alice_contribution 100)
        (= bob_contribution 0)
        (li alice_driver_commit bob_driver_commit 32 0 0
            (commit_hash commit guess_hash guess clue_hash clue))
    )
)

; my turn handler takes (local_move pre_state amount entropy raw_amount) and
; returns (binary_move their_turn_handler mover_share message_parser)

; their turn handler takes (remote_move pre_state post_state mover_share amount raw_amount) and
; returns (readable_info my_turn_handler list_of_evidence message)

; my turn driver
; local_move is the picked word. Needs to be in the dictionary
; checks that word is in dictionary
; next turn handler is a curried alice_driver_guess
(defun alice_driver_commit (local_move pre_state amount entropy raw_amount)
    (assert
        ; assert local_move is a word in the dictionary
        local_move_in_dictionary
        (assign
            salt (substr entropy 0 16)
            move (sha256 salt local_move raw_amount)
            (li move (curry alice_driver_guess salt move))
        )
    )
)

; their turn driver
; checks for Bob's guess being in dictionary
; readable_move is Bob's guess
; next turn handler is alice_driver_clue or nil if Bob guessed right or ran out of guesses
(defun alice_driver_guess (PREIMAGE WORD remote_move pre_state post_state mover_share)
    (assign
        evidence check_if_word_in_dictionary
        (if evidence
            (li 0 0 (li evidence))
            (assign
                clue (make_clue WORD remote_move)
                (li (li remote_move (expand_clue clue)) (curry alice_driver_clue PREIMAGE WORD clue))
            )
        )
    )
)

; my turn driver
; local_move is nil (should be called immediately)
; next turn handler is alice_driver_guess
(defun alice_driver_clue (PREIMAGE WORD CLUE local_move (bob_guesses alice_clues guess_validate_hash dictionary_key alice_commit)
        amount entropy raw_amount)
    (if (= CLUE right_word)
        (li (concat PREIMAGE WORD) 0 (index (li 100 100 20 5 1) (len alice_clues)))
        (= (len alice_clues 4))
        (li (concat PREIMAGE WORD) 0 0)
        (li CLUE (curry alice_driver_guess PREIMAGE WORD))
    )
)

; their turn driver
; no special checks
; readable_move is nil
; next turn handler is bob_driver_guess
(defun bob_driver_commit (remote_move pre_state post_state mover_share amount raw_amount)
    (li 0 bob_driver_guess)
)

; my turn driver
; local_move is a guess word. Needs to be in the dictionary
; next turn handler is bob_driver_clue
(defun bob_driver_guess (local_move pre_state amount entropy raw_amount)
    (assert
        (not (make_evidence my_dictionary local_move))
        (local_move bob_driver_clue)
    )
)

; their turn driver
; when there's a reveal, special check is Alice's word being in dictionary
; when there's a reveal possible evidence is indices of alice clues
; readable_move is a clue and optionally a reveal of Alice's word if done
; next turn handler is bob_driver_guess or nil if done
(defun bob_driver_clue (remote_move (bob_guesses alice_clues guess_validate_hash dictionary_key alice_commit)
        post_state mover_share amount raw_amount)
    (if (= (len remote_move) 1)
        (li (expand_clue remote_move) bob_driver_guess)
        (assign
            word (substr remote_move 16 21)
            evidence (make_evidence my_dictionary word)
            evidence2 (no_credit_evidence bob_guesses word)
            evidence3 (wrong_clue_evidence (r bob_guesses) alice_clues word 0x00)
            (if evidence
                (li 0 0 (li evidence))
                evidence2
                (li 0 0 (li evidence2))
                evidence3
                (li 0 0 (li evidence3))
                (li (li word (make_clue word (f bob_guesses))))
            )
        )
    )
)

(defun wrong_clue_evidence (bob_guesses alice_clues word so_far)
    (if (not bob_guesses)
        0
        (!= (make_clue (f bob_guesses) word) (f alice_clues))
        so_far
        (wrong_clue_evidence (r bob_guesses) (r alice_clues) word (+ 1 so_far))
    )
)

(defun no_credit_evidence (old_guesses word)
    (assign
        fail_index (no_credit_inner (r old_guesses) word 0x00)
        (if fail_index
            (concat 0x00 fail_index)
            0
        )
    )
)

(defun no_credit_inner (old_guesses word so_far)
    (if (not old_guesses)
        0
        (= (f old_guesses) word)
        so_far
        (no_credit_inner (r old_guesses) word (+ 1 so_far))
    )
)

; Alice gives wrong clue in each position with Bob guessing right in each position
; Alice commits to invalid word with correct clues and reveals in each position
; Alice tries to give Bob zero when he gets the last guess right
; Alice gives a clue out of range
; Alice gives a zero length clue
; Alice gives a too short reveal
; Bob guesses a too short word
