
(import games.calpoker-v1.onchain.a exposing (program as pokera) (program_hash as pokera_hash))
(import games.calpoker-v1.onchain.b exposing (program as pokerb) (program_hash as pokerb_hash))
(import games.calpoker-v1.onchain.c exposing (program as pokerc) (program_hash as pokerc_hash))
(import games.calpoker-v1.onchain.d exposing (program as pokerd) (program_hash as pokerd_hash))
(import games.calpoker-v1.onchain.e exposing (program as pokere) (program_hash as pokere_hash))

(import std.li)
(import std.curry)
(import std.map)
(import std.assert)
(import std.append)
(import std.relops)
(import std.list_compare)
(import std.deep_compare)
(import std.print)
(import games.calpoker-v1.handcalc exposing handcalc)
(import games.calpoker-v1.onchain.make_card exposing make_card)
(import games.calpoker-v1.onchain.make_cards exposing make_cards)
(import games.calpoker-v1.onchain.arrange_cards exposing get_final_cards_in_canonical_order)

; initial_mover_handler initial_waiter_handler whether_paired required_size_factor
; initial_max_move_size initial_validator initial_validator_hash
; initial_state initial_mover_share_proportion
(defun calpoker_template 0 (li calpoker_alice_handler_a calpoker_bob_handler_a 0 200 32 pokera pokera_hash 0 100))

; state is empty
; local_move is nil
; makes a move using entropy
(defun calpoker_alice_handler_a (local_move amount state split entropy)
    (assign
        preimage (substr entropy 0 16)
        image (sha256 preimage)
        (list
            "calpoker_alice_handler_a"
            image
            pokera
            pokera_hash
            pokerb
            pokerb_hash
            48
            0
            (curry calpoker_alice_handler_b preimage)
        )
    )
)

; state is (alice_commit bob_seed)
; move is Bob's seed
; immediately sends a message giving Alice's seed
(defun calpoker_alice_handler_b (PREIMAGE amount state move validation_info_hash split)
    (list
        (make_cards_readable (sha256 PREIMAGE move amount))
        0
        (curry calpoker_alice_handler_c PREIMAGE)
        PREIMAGE
    )
)

(defun single-byte (raw-indices)
    (if raw-indices
        (assign
            indices-len (strlen raw-indices)
            (substr raw-indices (- indices-len 1) indices-len)
        )
        0x00
    )
)

; state is (alice_commit bob_seed)
; move is Alice's reveal of her card generating seed and her commit to which cards she's picking
(defun calpoker_alice_handler_c (PREIMAGE my_discards amount state split entropy)
    (assign
        salt (substr entropy 0 16)
        new_commit (sha256 (concat salt my_discards))
        (list
            "calpoker_alice_handler_c"
            (concat PREIMAGE new_commit)
            pokerc
            pokerc_hash
            pokerd
            pokerd_hash
            1
            0
            (curry calpoker_alice_handler_d salt my_discards)
        )
    )
)

(defun indices_to_bitfield_inner (mylist index)
    (if (not mylist)
        0
        (= (f mylist) index)
        (logior 1 (lsh (indices_to_bitfield_inner (r mylist) (+ index 1)) 1))
        (lsh (indices_to_bitfield_inner mylist (+ index 1)) 1)
    )
)

(defun indices_to_bitfield (mylist)
    (single-byte (indices_to_bitfield_inner mylist 0))
)

; We have composed cards as sublists but need them as pairs.
(defun card_list_to_pair ((rank suit)) (c rank suit))

; state is (bob_discards alice_cards bob_cards alice_commit)
; move is Bob's discards
; should get an immediatel call back with a nil move
(defun calpoker_alice_handler_d (MY_SALT MY_PICKS amount
            (bob_discards alice_cards bob_cards my_commit) move validation_program_hash split)
    (assign
        (my_all_cards_indices bob_all_cards_indices) (get_final_cards_in_canonical_order
            alice_cards MY_PICKS bob_cards move) ;alice_cards alice_picks bob_cards bob_picks

        my_all_cards (map make_card (print "make card alice" my_all_cards_indices))
        bob_all_cards (map make_card (print "make card bob" bob_all_cards_indices))

        (my_hand_value my_selects) (handcalc (map card_list_to_pair (print "my all cards" my_all_cards)))
        (bob_hand_value bob_selects) (handcalc (map card_list_to_pair (print "bob all cards" bob_all_cards)))
        ;; win_result is 1 if my_hand_value is greater than bob_hand_value
        win_result (list_compare my_hand_value bob_hand_value)
        ;; split is captured in a their turn handler below so it's the opposite of what
        ;; this turn would specify.
        split (if (= win_result 1) 0 (= win_result 0) (lsh amount -1) amount)
        (list
            (list
                move
                (indices_to_bitfield my_selects)
                (indices_to_bitfield bob_selects)
                my_hand_value
                bob_hand_value
                win_result
            )
            0
            (curry calpoker_alice_handler_e (concat MY_SALT MY_PICKS (single-byte (indices_to_bitfield my_selects))) split)
        )
    )
)

; output of e.clsp:
;    (alice_discards alice_card_selections alice_cards bob_cards alice_final_cards bob_final_cards)
; run after e.clsp
; Alice makes a nil move to message Bob who won
(defun calpoker_alice_handler_e (NEXT_MOVE SPLIT local_move amount state last_mover_share entropy)
    (list
        "calpoker_alice_handler_e"
        NEXT_MOVE
        pokere
        pokere_hash
        0
        0
        0
        SPLIT
        0
    )
)

; state is alice_commit
; move is Alice commit to a salted word
(defun calpoker_bob_handler_a (amount state move validation_program_hash split)
    (list 0 0 calpoker_bob_handler_b)
)

; state is alice_commit
; move is bob_seed
(defun calpoker_bob_handler_b (local_move amount state split entropy)
    (list
        "calpoker_bob_handler_b"
        (substr entropy 0 16)
        pokerb
        pokerb_hash
        pokerc
        pokerc_hash
        48
        0
        calpoker_bob_handler_c
        parse_message
    )
)

(defun parse_message (message (alice_commit bob_seed) amount)
    (assert
        (= (sha256 message) alice_commit)
        (make_cards_readable (sha256 (substr message 0 16) (substr bob_seed 0 16) amount))
    )
)

; state is (alice_commit alice_cards bob_cards)
; move is Alice's reveal of her card generating seed and her commit to which cards she's picking
; expecting a message revealing Alice's seed which results in local display once verified
(defun calpoker_bob_handler_c (amount (alice_commit alice_cards bob_cards) move validation_program_hash split)
    (list
        (list (make_readable_card_descriptions alice_cards) (make_readable_card_descriptions bob_cards))
        0
        calpoker_bob_handler_d
    )
)

; state is ((alice_cards bob_cards) alice_pick_commitment)
; move is Bob's discards
(defun calpoker_bob_handler_d (my_move amount state split entropy)
    (list
        "calpoker_bob_handler_d"
        my_move
        pokerd
        pokerd_hash
        pokere
        pokere_hash
        18
        0
        calpoker_bob_handler_e
        0
    )
)

; state is (bob_discards alice_cards bob_cards alice_final_cards bob_final_cards alice_hand_value)
; move is alice_salted_discards
(defun calpoker_bob_handler_e (amount (bob_discards alice_cards bob_cards alice_final_cards
        bob_final_cards alice_hand_value) move validation_program_hash split)
    (assign
        alice_discards (substr move 16 17)
        alice_selects (substr move 17 (strlen move))
        (bob_hand_value bob_selects) (handcalc (map card_list_to_pair (map make_card bob_final_cards)))
        (list
            (list
                (print "alice discards" alice_discards)
                (print "alice selects" alice_selects)
                (print "bob selects" (indices_to_bitfield bob_selects))
                (print "alice hand value" alice_hand_value)
                (print "bob hand value" bob_hand_value)
                (print "compare result" (deep_compare (print "split was" split) (print "amt div 2" (/ amount 2))))
            )
            (list (indices_to_bitfield bob_selects))
            0
        )
    )
)

(defun make_cards_readable (seed)
    (assign
        (cardsa cardsb) (make_cards seed)
        (list (map make_card_readable cardsa) (map make_card_readable cardsb))
    )
)

(defun make_readable_card_descriptions (cards) (map make_card_readable cards))

(defun make_card_readable (val)
    (assign
        (rank . suit) (divmod val 4)
        (list (+ 2 rank) (+ 1 suit))
    )
)
