(export space_poker_factory)

(import spacehandcalc)

; game factory takes (alice_contribution bob_contribution) and returns
; (initial_mover_handler initial_waiter_handler
; initial_max_move_size initial_state initial_mover_share
; (validator_hash validator validator_hash validator ...) first one is initial)
(defun space_poker_factory (alice_contribution bob_contribution)
    (assert
        (= alice_contribution bob_contribution)
        (li commitA_my_turn commitA_their_turn 32 (+ alice_contribution bob_contribution) alice_contribution
        (li commitA_hash commitA commitB_hash commitB begin_round_hash begin_round
        mid_round_hash mid_round end_hash end))
    )
)

; TODO: Refactor this so half_pot is implicit. This requires changes to the on-chain
; code and for this code to get passed mover_share in units

; my turn handler takes (local_move pre_state amount entropy raw_amount) and
; returns (binary_move their_turn_handler mover_share message_parser)

; their turn handler takes (remote_move pre_state post_state mover_share amount raw_amount) and
; returns (readable_info my_turn_handler list_of_evidence message)

; user_move is nil
; state is units_on_table
(defun commitA_my_turn (local_move units_on_table amount entropy raw_amount)
    (assign
        my_move (sha256 (sha256 (sha256 (sha256 (sha256 entropy raw_amount)))))
        (li my_move (curry commitB_ther_turn entropy) (/ amount 2))
    )
)

; readable is nil
; prestate is units_on_table
; poststate is (units_on_table their_image_5)
(defun commitA_their_turn (remote_move prestate (units_on_table their_image_5) mover_share amount raw_amount)
    (li 0 commitB_my_turn)
)

; user_move is nil
; state is (units_on_table their_image_5)
(defun commitB_my_turn (local_move (units_on_table their_image_5) amount entropy raw_amount)
    (assign
        my_move (sha256 (sha256 (sha256 (sha256 (sha256 entropy raw_amount)))))
        (li my_move (curry begin_preflop_their_turn entropy) (/ amount 2))
    )
)

; readable is (whether_we_go_first, my_hole_cards)
; prestate is (units_on_table my_image_5)
; poststate is (units_on_table half_pot_size my_image_5 their_image_4 n_4)
(defun commitB_their_turn (MY_PREIMAGE their_image_4 prestate poststate mover_share amount raw_amount)
    (assign
        my_hole_cards (make_cards remote_move (sha256 MY_PREIMAGE raw_amount) 2)
        my_image_4 (sha256 (sha256 (sha256 (sha256 (sha256 MY_PREIMAGE raw_amount)))))
        ; there is a 50% chance the orientation of this is wrong
        is_my_turn (< (sha256 their_image_4 my_image_4) (sha256 my_image_4 their_image_4))
        (li (is_my_turn my_hole_cards) (curry begin_preflop_my_turn MY_PREIMAGE my_turn) 0 my_image_4)
    )
)

; if we go first user_move is raise amount and state goes to continue_preflop_their_turn
; if they go first user_move is nil and and state goes to begin_preflop_their_turn
; state is (units_on_table half_pot_size my_image_5 their_image_4 4)
(defun begin_preflop_my_turn (MY_PREIMAGE IS_MY_TURN raise_amount (units_on_table half_pot_size my_image_5 their_image_4 n_4) amount entropy raw_amount)
    (assign
        my_image_4 (sha256 (sha256 (sha256 (sha256 (sha256 MY_PREIMAGE raw_amount)))))
        (if IS_MY_TURN
            (assert
                (>= raise_amount 0)
                (<= (* 2 (+ half_pot raise_amount)) units_on_table)
                (li (concat my_image_4 raise_amount) (curry continue_preflop_their_turn MY_PREIMAGE) (/ units_on_table 2))
            )
            (li my_image_4 (curry begin_preflop_their_turn MY_PREIMAGE) half_pot_size 0
                (curry parse_message_for_begin_preflop_their_turn MY_PREIMAGE raw_amount))
        )
    )
)

(defun parse_message_for_begin_preflop_their_turn (MY_PREIMAGE RAW_AMOUNT THEIR_IMAGE_5 message)
    (assert
        (= strlen message 32)
        (= (sha256 message) THEIR_IMAGE_5)
        (make_cards message (sha256 MY_PREIMAGE RAW_AMOUNT) 2)
    )
)

; if we go first readable is (True, my_hole_cards) and state goes to begin_preflop_my_turn
; if they go first readable is (False, raise_amount, my_hole_cards) and state goes to continue_preflop_my_turn
; my_hole_cards is previewed from message
; prestate is (units_on_table half_pot_size their_image_5 my_image_4 n_4)
; if we move first poststate is (units_on_table half_pot_size their_image_5 my_image_4 n_4)
; if they move first poststate is (units_on_table half_pot raise_amount their_image_4 my_image_4 n_4 begin_round_hash)
(defun begin_preflop_their_turn (MY_PREIMAGE remote_move pre_state (units_on_table half_pot raise_amount
        poststate mover_share amount raw_amount))
    (if (> (strlen remote_move) 32)
        ; they go first
        (assign
            (units_on_table half_pot raise_amount my_image_4 their_image_4 n_4 begin_round_hash) poststate
            my_hole_cards (make_cards their_image_4 (sha256 MY_PREIMAGE raw_amount) 2)
            (li (li 0 raise_amount my_hole_cards) (curry continue_preflop_my_turn MY_PREIMAGE))
        )
        ; we go first
        (assign
            my_hole_cards (make_cards remote_move (sha256 MY_PREIMAGE raw_amount) 2)
            (li (li 1 my_hole_cards) (curry begin_preflop_my_turn MY_PREIMAGE))
        )
    )
)

; user_move is raise amount, 0 for call
; state is (units_on_table half_pot raise_amount my_image_4 their_image_4 n_4 begin_round_hash)
(defun continue_preflop_my_turn (MY_PREIMAGE my_reraise_amount
            (units_on_table half_pot raise_amount my_image_4 their_image_4 n_4 begin_round_hash)
            amount entropy raw_amount)
    (assert
        (>= my_reraise_amount 0)
        (<= (* 2 (+ half_pot raise_amount)) units_on_table)
        (if my_reraise_amount
            ; we're raising
            (li my_reraise_amount (curry continue_preflop_their_turn MY_PREIMAGE) (+ half_pot raise_amount))
            ; we're calling
            (li (sha256 (sha256 (sha256 (sha256 MY_PREIMAGE raw_amount)))) (curry begin_flop_their_turn MY_PREIMAGE) (+ half_pot raise_amount)
                (curry parse_message_for_begin_flop_their_turn MY_PREIMAGE raw_amount their_image_4))
        )
    )
)

; readable is (raise_amount, flop_cards) flop_cards is nil if raise amount is not 0
; prestate is (units_on_table half_pot raise_amount their_image_4 my_image_4 n_4 begin_round_hash)
; if raise_amount > 0 poststate is (units_on_table half_pot raise_amount my_image_4 their_image_4 n_4 begin_round_hash)
; if raise amount = 0 poststate is (units_on_table half_pot_size my_image_4 their_image_3 n_3)
(defun continue_preflop_their_turn (MY_PREIMAGE remote_move pre_state post_state mover_share amount raw_amount)
    (if (= (strlen remote_move) 32)
        ; they called
        (assign
            my_image_3 (sha256 (sha256 (sha256 (sha256 MY_PREIMAGE raw_amount))))
            (li (li 0 (make_cards remote_move my_image_3 3)) (curry begin_flop_my_turn MY_PREIMAGE) 0 my_image_3)
        )
        ; they raised
        (li (li remote_move 0) (curry continue_flop_my_turn MY_PREIMAGE))
    )
)

; user_move is raise amount
; state is (units_on_table half_pot_size my_image_4 their_image_3 n_3)
(defun begin_flop_my_turn (MY_PREIMAGE local_move (units_on_table half_pot_size my_image_4 their_image_3 n_3) amount entropy raw_amount)
    (assign
        my_image_3 (sha256 (sha256 (sha256 (sha256 MY_PREIMAGE raw_amount))))
        (assert
            (>= raise_amount 0)
            (<= (* 2 (+ half_pot raise_amount)) units_on_table)
            (li (concat my_image_3 raise_amount) (curry continue_flop_their_turn MY_PREIMAGE) half_pot_size)
        )
    )
)

(defun parse_message_for_begin_flop_their_turn (MY_PREIMAGE RAW_AMOUNT THEIR_IMAGE_4 message)
    (assert
        (= strlen message 32)
        (= (sha256 message) THEIR_IMAGE_4)
        (make_cards message (sha256 (sha256 (sha256 (sha256 MY_PREIMAGE RAW_AMOUNT)))) 3)
    )
)

; readable is (raise_amount, flop_cards)
; flop_cards is previewed from message
; prestate is (units_on_table half_pot_size their_image_4 my_image_3 n_3)
; poststate is (units_on_table half_pot raise_amount my_image_3 their_image_3 n_3 begin_round_hash)
(defun begin_flop_their_turn (MY_PREIMAGE remote_move pre_state post_state mover_share amount raw_amount)
    (assign
        (units_on_table half_pot raise_amount my_image_3 their_image_3 n_3 begin_round_hash) post_state
        flop_cards (make_cards their_image_3 my_image_3 3)
        (li (li raise_amount flop_cards) (curry continue_flop_my_turn MY_PREIMAGE))
    )
)

; user_move is raise amount, 0 for call
; state is (units_on_table half_pot raise_amount my_image_3 their_image_3 n_3 begin_round_hash)
(defun continue_flop_my_turn (MY_PREIMAGE my_reraise_amount pre_state amount entropy raw_amount)
    (assert
        (>= my_reraise_amount 0)
        (<= (* 2 (+ half_pot raise_amount)) units_on_table)
        (if my_reraise_amount
            ; we're raising
            (li my_reraise_amount (curry continue_flop_their_turn MY_PREIMAGE) (+ half_pot raise_amount))
            ; we're calling
            (li (sha256 (sha256 (sha256 MY_PREIMAGE raw_amount))) (curry begin_turn_their_turn MY_PREIMAGE) (+ half_pot raise_amount)
                (curry parse_message_for_begin_turn_their_turn MY_PREIMAGE raw_amount their_image_3))
        )
    )
)

; readable is (raise_amount, turn_card) turn_card is nil if raise amount is not 0
; prestate is (units_on_table half_pot raise_amount their_image_3 my_image_3 n_3 begin_round_hash)
; if raise_amount > 0 poststate is (units_on_table half_pot raise_amount my_image_3 their_image_3 n_3 begin_round_hash)
; if raise amount = 0 poststate is (units_on_table half_pot_size my_image_3 their_image_2 n_2)
(defun continue_flop_their_turn (MY_PREIMAGE remote_move pre_state post_state mover_share amount raw_amount)
    (if (= (strlen remote_move) 32)
        ; they called
        (assign
            my_image_2 (sha256 (sha256 (sha256 MY_PREIMAGE raw_amount)))
            (li (li 0 (make_cards remote_move my_image_2 1)) (curry begin_turn_my_turn MY_PREIMAGE) 0 my_image_2)
        )
        ; they raised
        (li (li remote_move 0) (curry continue_flop_my_turn MY_PREIMAGE))
    )
)

; user_move is raise amount
; state is (units_on_table half_pot_size my_image_3 their_image_2 n_2)
(defun begin_turn_my_turn (MY_PREIMAGE raise_amount pre_state amount entropy raw_amount)
    (assign
        (units_on_table half_pot_size my_image_3 their_image_2 n_2) pre_state
        my_image_2 (sha256 (sha256 (sha256 MY_PREIMAGE raw_amount)))
        (assert
            (>= raise_amount 0)
            (<= (* 2 (+ half_pot raise_amount)) units_on_table)
            (li (concat my_image_2 raise_amount) (curry continue_turn_their_turn MY_PREIMAGE) half_pot_size)
        )
    )
)

(defun parse_message_for_begin_turn_their_turn (MY_PREIMAGE RAW_AMOUNT THEIR_IMAGE_3 message)
    (assert
        (= strlen message 32)
        (= (sha256 message) THEIR_IMAGE_3)
        (f (make_cards message (sha256 (sha256 (sha256 MY_PREIMAGE RAW_AMOUNT))) 1))
    )
)

; readable is (raise_amount, turn_card)
; turn_card is previewed from message
; prestate is (units_on_table half_pot_size their_image_3 my_image_2 n_2)
; poststate is (units_on_table half_pot raise_amount my_image_2 their_image_2 n_2 begin_round_hash)
(defun begin_turn_their_turn (MY_PREIMAGE remote_move pre_state post_state mover_share amount raw_amount)
    (assign
        (units_on_table half_pot raise_amount my_image_2 their_image_2 n_2 begin_round_hash) post_state
        (turn_card) (make_cards their_image_2 my_image_2 1)
        (li (li raise_amount turn_card) (curry continue_turn_my_turn MY_PREIMAGE))
    )
)

; user_move is raise amount, 0 for call
; state is (units_on_table half_pot raise_amount my_image_2 their_image_2 n_2 begin_round_hash)
(defun continue_turn_my_turn (MY_PREIMAGE my_reraise_amount
        (units_on_table half_pot raise_amount my_image_2 their_image_2 n_2 begin_round_hash)
        amount entropy raw_amount)
    (assert
        (>= my_reraise_amount 0)
        (<= (* 2 (+ half_pot raise_amount)) units_on_table)
        (if my_reraise_amount
            ; we're raising
            (li my_reraise_amount (curry continue_turn_their_turn MY_PREIMAGE) (+ half_pot raise_amount))
            ; we're calling
            (li (sha256 (sha256 MY_PREIMAGE raw_amount)) (curry begin_river_their_turn MY_PREIMAGE) (+ half_pot raise_amount)
                (curry parse_message_for_begin_river_their_turn MY_PREIMAGE raw_amount their_image_2))
        )
    )
)

; readable is (raise_amount river_card) river_card is nil if raise amount is not 0
; prestate is (units_on_table half_pot raise_amount their_image_2 my_image_2 n_2 begin_round_hash)
; if raise_amount > 0 poststate is (units_on_table half_pot raise_amount my_image_2 their_image_2 n_2 begin_round_hash)
; if raise amount = 0 poststate is (units_on_table half_pot_size my_image_2 their_image_1 n_1)
(defun continue_turn_their_turn (MY_PREIMAGE remote_move pre_state post_state mover_share amount raw_amount)
    (if (= (strlen remote_move) 32)
        ; they called
        (assign
            my_image_1 (sha256 (sha256 MY_PREIMAGE raw_amount))
            (li (li 0 (f (make_cards remote_move my_image_1 1))) (curry begin_river_my_turn MY_PREIMAGE) 0 my_image_1)
        )
        ; they raised
        (li (li remote_move 0) (curry continue_turn_my_turn MY_PREIMAGE))
    )
)

; user_move is raise amount
; state is (units_on_table half_pot_size my_image_2 their_image_1 n_1)
(defun begin_river_my_turn (MY_PREIMAGE local_move pre_state amount entropy raw_amount)
    (assign
        (units_on_table half_pot_size my_image_2 their_image_1 n_1) pre_state
        my_image_1 (sha256 (sha256 MY_PREIMAGE raw_amount))
        (assert
            (>= raise_amount 0)
            (<= (* 2 (+ half_pot raise_amount)) units_on_table)
            (li (concat my_image_1 raise_amount) (curry continue_river_their_turn MY_PREIMAGE) half_pot_size)
        )
    )
)

(defun parse_message_for_begin_river_their_turn (MY_PREIMAGE RAW_AMOUNT THEIR_IMAGE_2 message)
    (assert
        (= strlen message 32)
        (= (sha256 message) THEIR_IMAGE_2)
        (f (make_cards message (sha256 (sha256 MY_PREIMAGE RAW_AMOUNT))) 1)
    )
)

; readable is (raise_amount, river_card)
; river_card is previewed from message
; prestate is (units_on_table half_pot_size their_image_2 my_image_1 n_1)
; poststate is (units_on_table half_pot raise_amount my_image_1 their_image_1 n_1 begin_round_hash)
(defun begin_river_their_turn (MY_PREIMAGE remote_move pre_state post_state mover_share amount raw_amount)
    (assign
        (units_on_table half_pot raise_amount my_image_1 their_image_1 n_1 begin_round_hash) post_state
        (river_card) (make_cards their_image_1 my_image_1 1)
        (li (li raise_amount river_card) (curry continue_turn_my_turn MY_PREIMAGE))
    )
)

; user_move is raise amount, 0 for call
; state is (units_on_table half_pot raise_amount my_image_1 their_image_1 n_1 begin_round_hash)
(defun continue_river_my_turn (MY_PREIMAGE my_reraise_amount
        (units_on_table half_pot raise_amount my_image_1 their_image_1 n_1 begin_round_hash)
        amount entropy raw_amount)
    (assert
        (>= my_reraise_amount 0)
        (<= (* 2 (+ half_pot raise_amount)) units_on_table)
        (if my_reraise_amount
            ; we're raising
            (li my_reraise_amount (curry continue_river_their_turn MY_PREIMAGE) (+ half_pot raise_amount))
            ; we're calling
            (li MY_PREIMAGE (curry end_their_turn MY_PREIMAGE) (+ half_pot raise_amount))
        )
    )
)

; readable is (raise_amount, their_hole_cards, my_card_selections, their_card_selections, my_hand_value, their_hand_value)
; everything past raise_amount is only there if raise_amount is 0
; prestate is (units_on_table half_pot raise_amount their_image_1 my_image_1 n_1 begin_round_hash)
; if raise_amount > 0 poststate is (units_on_table half_pot raise_amount my_image_1 their_image_1 n_1 begin_round_hash)
; if raise amount = 0 poststate is (units_on_table half_pot raise_amount my_image_1 their_preimage)
(defun continue_river_their_turn (MY_PREIMAGE remote_move pre_state post_state mover_share amount raw_amount)
    (if (= (strlen remote_move) 32)
        ; they called
        (assign
            my_image_0 (sha256 (sha256 MY_PREIMAGE raw_amount))
            (li (li 0 (f (make_cards remote_move my_image_0 1))) (curry end_my_turn MY_PREIMAGE) 0 MY_PREIMAGE)
        )
        ; they raised
        (li (li remote_move 0) (curry continue_river_my_turn MY_PREIMAGE))
    )
)

; user_move is nil
; state is (units_on_table half_pot raise_amount my_image_1 their_preimage)
(defun end_my_turn (MY_PREIMAGE local_move pre_state amount entropy raw_amount)
)

; readable is (their_hole_cards, my_card_selections, their_card_selections, my_hand_value, their_hand_value)
; prestate is (units_on_table half_pot raise_amount their_image_1 my_preimage)
; poststate is nil
(defun end_their_turn (remote_move pre_state post_state mover_share amount raw_amount)
)
