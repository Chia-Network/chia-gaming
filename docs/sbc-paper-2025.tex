\documentclass[a4paper]{article}

% Packages
\usepackage{geometry}
\geometry{left=1.5cm, right=1.5cm, top=2.54cm, bottom=2.54cm}
\usepackage{graphicx, hyperref, setspace, amsmath, amssymb, titlesec, fancyhdr, multicol, parskip, indentfirst, etoolbox, caption, cite, hyperref, xcolor}
\usepackage{array}
\renewcommand*{\arraystretch}{1.1}
\setlength{\extrarowheight}{2pt}

% Title Formatting
\titleformat{\section}{\centering\large\scshape}{\thesection}{1em}{}
\titleformat{\subsection}{\normalsize\bfseries}{\thesubsection.}{1em}{}

% Document Title
\title{
    \textbf{Chia Gaming: Real Time Games of Skill With Enforced Rules and no Trusted Third Party} 
    \thanks{
        \sloppy
        \textbf{Cite (APA):} Cohen, B., Kelly, A., \& Yerkes, A. (\the\year). Chia Gaming: Real Time Games of Skill. \textit{The Science of Blockchain Conference 2025}
    }
}
%\author

\date{} % No date

% Section Numbering
% Define numbering format
\renewcommand{\thesection}{\Roman{section}.}
\renewcommand{\thesubsection}{\textit{\Alph{subsection}.}}
\renewcommand{\thesubsubsection}{\textit{\arabic{subsubsection}.}}

% Make titles italic as well

\titleformat{\subsection}{\normalfont\large\itshape}{\thesubsection}{1em}{}
\titleformat{\subsubsection}{\normalfont\itshape}{\thesubsubsection}{1em}{}


\setcounter{page}{5}

% Fancy Header Configuration
\pagestyle{fancy}
\fancyhf{} % Clear all header/footer fields

% First Page Header
\fancypagestyle{firstpage}{
    \fancyhead[C]{
        \centering
        {\fontsize{14pt}{12pt}\selectfont
        \textbf{Science of Blockchain 2025}\\
        \textbf{Conference Article}}\\
        {\fontsize{8pt}{10pt}\selectfont
        \textbf{Received:} 2025-03-13 \textbf{Reviewing:} 2025-MM-DD \& 2025-MM-DD \textbf{Accepted:} 2025-MM-DD \textbf{Online:} 2025-MM-DD \textbf{Issue Date:} 2025-MM-DD}\\
        \textbf{Year:} 2025, \textbf{Volume:} X, \textbf{Issue:} X, \textbf{Pages:} XX-XX, \textbf{Doi:} 10.57019/jmv.XXXXXX
    }
}

% Default Header for Other Pages
\fancyhead[C]{\textbf{The Science of Blockchain Conference 2025}}

%\fancyfoot[L]{\includegraphics[width=1.5cm]{cc-by.png}}  % Adjust path & size
%\fancyfoot[R]{\includegraphics[width=1.5cm]{cc-by.png}}  % Adjust path & size
%\fancyfoot[C]{This work is licensed under a Creative Commons Attribution 4.0 International License.\\ \thepage}


\begin{document}



% Multi-line left-aligned text with manual line breaks.
% The base line is in centre.
\newcommand*{\mline}[1]{%
\begingroup
    \renewcommand*{\arraystretch}{1.1}%
   \begin{tabular}[c]{@{}>{\raggedright\arraybackslash}p{2cm}@{}}#1\end{tabular}%
  \endgroup
}


\maketitle
\vspace{-1.5cm}
\thispagestyle{firstpage}

% Authors Block
\begin{multicols}{3}
	\centering
	\textbf{Bram Cohen}\\
	\textit{Chia, Inc.}\\
	\textit{bram@chia.net}\\
	\vfill
        \textbf{Adam Kelly}\\
	\textit{Chia, Inc.}\\
	\textit{adam@chia.net}\\
	\vfill
        \textbf{Art Yerkes}\\
	\textit{Chia, Inc.}\\
	\textit{a.yerkes@chia.net}\\
	\vfill
\end{multicols}

\singlespacing
\setlength{\parskip}{6pt}
\setlength{\parindent}{0.5cm}

\begin{multicols}{2}
\setlength{\columnsep}{0.5cm}

\section{Introduction}
We give an explanation of an implementation of real-time gaming on top of Chia using state channels. It supports two-player, turn-based games. It enforces the game rules without requiring any trusted third party.

\subsection{Background}
TODO: Discuss the history and cite a few papers. 

\subsubsection{State Channels vs. Payment Channels}
Lightning network \cite{1} is by far the largest user of channels to date. It is a payment channel network that supports real-time payments between two counterparties who do not have a preexisting direct relationship with each other by routing through intermediaries. In order to support this, it requires pre-funding of payment channels. It does not support full-blown state channels because Bitcoin Script cannot support the complex logic required by unroll coins. State Channels are much more complex to route. 

Chia gaming does not have a static channel network. Each session is ephemeral, requiring one transaction at the start of a session to set up the channel and another one at the end to tear it down. If there is an issue in the middle of a session, the state channel is unrolled to chain, and any hands pending at that time have to play out on chain.

Routing of Chia state channels can be done, but has not been implemented yet. It has the benefit of not needing a new transaction on chain at the beginning of each session, but comes with the downsides of needing prepaid liquidity across an entire network and requires much more complex logic to implement than routed payments.


\begin{table}
  \caption{Comparing State Channels \& Payment Channels}
  \label{xxx}
 %\begin{tabular}{ |p{4cm}||p{2cm}|p{2cm}|  }
 %\begin{tabular}{ |c|c|c| }
 \begin{tabular}{ m{5em} | m{2em} | m{2em} }
 \centering
 \bfseries Property& \bfseries Lightning&\bfseries Chia Gaming\\
 \hline
 \mline{Real Time}   & Yes    &Yes\\
 \hline
 \mline{Based on ‘virtual’ coins which can be made real in an unroll}&   Yes  & Yes   \\
  \hline
 \mline{Requires setup at start of session} &no & Yes\\
  \hline
 \mline{Preexisting liquidity requirement}    &Yes & no\\
  \hline
 \mline{Supports Gaming}&   no  & Yes\\
  \hline
 \mline{Method of handling obsolete unroll}& Slash  & Update   \\
  \hline
 \mline{Supported Network}& Bitcoin  & Chia\\
 \hline
\end{tabular}
\end{table}

\subsubsection{The coin set model vs. the UTXO model}
The Chia on chain programming environment is a good fit for channels because it was designed from the ground up to support them, based on lessons learned from Bitcoin. The table below contains an overview of the relevant differences:


\begin{tabular}{ |p{4cm}|p{4cm}|  }
 \hline
 \multicolumn{2}{|c|}{Coin Set vs. UTXO} \\
 \hline
 Bitcoin & Chia\\
 \hline\hline
 UTXO model. Only UTXOs, their sizes, spend requirements, and birthdays are stored. & Coin set model. Only things stored are coins IDs, their sizes, spend requirements, and birthdays.\\
 \hline
 UTXOs are identified using hash of transaction and index & Coins are identified using parent id and puzzle hash and size\\
 \hline
 Scriptpubkeys are passed the transaction (which includes new output creation) and either fail or accept it & Puzzles are passed solutions and return conditions which include creation of new coins\\
 \hline
 Bitcoinscript only supports simple logic and can only support covenants via hash chaining & CLVM trivially supports covenants and can implement capabilities using shells around puzzles.\\
 Signatures are required to be tied to a specific coin & Signatures can be tied to a specific coin, puzzle, or neither\\
 \hline
 Supports signature aggregation via multi-round protocol on top of sekp & Supports trivial signature aggregation using BLS\\
 \hline
\end{tabular}

\section{TLA+ Model discussion}

TLA+ \cite{2} is a formal proof system for modeling programs and systems, especially concurrent and distributed systems. The authors make use of this tool to prove that there are no states that cannot reach the "end game" state. Note that this TLA+ code only models what we consider to be the "game" (\textit{CalPoker} in this case), and not the State Channel itself.


\onecolumn

\section{Appendix}

\subsection{TLA+ Model for \textit{CalPoker} state machine}

\begin{verbatim}





---- MODULE potato_handler ----

EXTENDS Integers, Sequences, FiniteSets, TLC

VARIABLES a, b, ui_actions
RECURSIVE ProcessQueueActions(_)

\* States
StepA == 0
StepB == 1
StepC == 2
StepD == 3
StepE == 4
PostStepE == 5
StepF == 6
PostStepF == 7
Finished == 8
OnChainTransition == 9
OnChainWaitingForUnrollTimeoutOrSpend == 10
OnChainWaitForConditions == 11
OnChainWaitingForUnrollSpend == 12
OnChainWaitingForUnrollConditions == 13
OnChain == 14
Completed == 15
MaxHandshakeState == 16
Error == 1000

\* Channel Handler
ChannelHandlerEnded == 1001

\* Potato states
PotatoPresent == 1
PotatoAbsent == -1
PotatoRequested == 0

\* Messages
HandshakeA == 0
HandshakeB == 1
HandshakeE == 4
HandshakeF == 5
UIStartGames == 6
UIStartGamesError == 7
UIStartGamesLocalError == 107
Nil == 10
NilError == 11
NilLocalError == 111
StartGames == 12
StartGamesError == 13
StartGamesLocalError == 113
Move == 14
MoveError == 15
MoveLocalError == 115
Accept == 16
AcceptError == 17
AcceptLocalError == 117
Shutdown == 18
ShutdownError == 19
ShutdownLocalError == 119

DelayedStart == 20
RedoMove == 21
RedoAccept == 22

RequestPotato == 100
SendPotato == 101

Opponent == 10000

PotatoHandler(state) ==
  [ handshake_state |-> state,
    have_potato |-> PotatoPresent,
    messages |-> << >>,
    channel_initiation_transaction |-> 0,
    channel_puzzle_hash |-> 0,
    channel_transaction_sent |-> 0,
    channel_transaction_completed |-> 0,
    channel_handler |-> -1,
    waiting_to_start |-> 1,
    my_start_queue |-> << >>,
    their_start_queue |-> << >>,
    game_action_queue |-> << >>,
    incoming_messages |-> << >>
  ]

UIActions ==
  [ sent_moves |-> 0 ]

Init ==
  /\ a = PotatoHandler(StepA)
  /\ b = PotatoHandler(StepB)
  /\ ui_actions = UIActions

allvars == << a, b, ui_actions >>

\* Basic accessors
IsErr(v) == v[1] < 0
OkOf(v) == v[2]
Err(p) == << -1, p >>
Ok(p) == << 0, p >>
RvOf(p) == p[1]
Rv(v,p) == << v, p >>

NewState(p,s) == [p EXCEPT !.handshake_state = s]

SendMessage(p,m) == [p EXCEPT !.messages = Append(p.messages, m)]

DropMessage(p) == [p EXCEPT !.messages = Tail(p.messages)]

FirstMessage(p) == p.messages[1]

PotatoState(p,ps) == [p EXCEPT !.have_potato = ps]

SetChannelHandler(p, ch) == [p EXCEPT !.channel_handler = ch + 0]

FirstGameActionQueue(p) == p.game_action_queue[1]

DropGameActionQueue(p) == [p EXCEPT !.game_action_queue = Tail(p.game_action_queue)]

FirstMyStartQueue(p) == p.my_start_queue[1]

DropMyStartQueue(p) == [p EXCEPT !.my_start_queue = Tail(p.my_start_queue)]

AppendMyStartQueue(p,s) == [p EXCEPT !.my_start_queue = Append(p.my_start_queue, s)]

DropTheirStartQueue(p) == [p EXCEPT !.their_start_queue = Tail(p.their_start_queue)]

AppendTheirStartQueue(p,s) == [p EXCEPT !.their_start_queue = Append(p.their_start_queue, s)]

AppendIncoming(p,m) == [p EXCEPT !.incoming_messages = Append(p.incoming_messages, m)]

DropIncomingMessage(p) == [p EXCEPT !.incoming_messages = Tail(p.incoming_messages)]

\* Err
ChannelHandler(p) ==
  IF p.channel_handler < 0 THEN
    Err(0)
  ELSE
    Ok(p.channel_handler)

SendPotatoHandlerCommand(p, ch, msg) ==
  SendMessage(p, msg)

SendChannelHandlerCommand(p, ch, msg) ==
  IF msg > 100 THEN
    Err(ch)
  ELSE
    Ok(SendPotatoHandlerCommand(SetChannelHandler(p, ch), ch, msg))

SendPotatoStartGame(p, ch, msg) == SendChannelHandlerCommand(p, ch, msg)
  
SendPotatoMove(p, ch, msg) == SendChannelHandlerCommand(p, ch, msg)

SendPotatoAccept(p, ch, msg) == SendChannelHandlerCommand(p, ch, msg)

SendPotatoCleanShutdown(p, ch, msg) ==
  LET p1 == SendChannelHandlerCommand(p, ch, msg) IN
  IF IsErr(p1) THEN
    p1
  ELSE
    Ok(SetChannelHandler(OkOf(p1), ChannelHandlerEnded))

ReceivedChannelHandlerCommand(ch, msg) ==
  IF msg % 2 = 1 THEN
    Err(ch)
  ELSE
    Ok(ch + 1)

ReceivedPotatoStartGame(ch, msg) == ReceivedChannelHandlerCommand(ch, msg)
ReceivedEmptyPotato(ch, msg) == ReceivedChannelHandlerCommand(ch, msg)
ReceivedPotatoMove(ch, msg) == ReceivedChannelHandlerCommand(ch, msg)
ReceivedPotatoAccept(ch, msg) == ReceivedChannelHandlerCommand(ch, msg)
ReceivedPotatoCleanShutdown(ch, msg) == ReceivedChannelHandlerCommand(ch, msg)

\* Communication with outside during handshake
AskForChannelInitTransaction(p) == [p EXCEPT !.channel_puzzle_hash = 1]

ReplyChannelInitTransaction(p) ==
  [p EXCEPT !.channel_initiation_transaction = 1, !.channel_puzzle_hash = 2]

ReceivedChannelOffer(p) == [p EXCEPT !.channel_transaction_sent = 1]

EnqueueGameAction(p,act) ==
  [p EXCEPT !.game_action_queue = Append(p.game_action_queue, act)]

DropGameAction(p) ==
  [p EXCEPT !.game_action_queue = Tail(p.game_action_queue)]

FirstGameAction(p) ==
  p.game_action_queue[1]

NewChannelHandler(p) == [p EXCEPT !.channel_handler = 0]

\* potato_handler/mod.rs:265
Start(p) ==
  SendMessage(NewState(p, StepC), HandshakeA)

\* potato_handler/mod.rs:567
\* Return ( new_game, new_potato_handler )
HavePotatoStartGame(p) ==
  IF Len(p.their_start_queue) > 0 THEN
    LET ch == ChannelHandler(p) IN
    IF IsErr(ch) THEN
      Err(p)
    ELSE
      LET ch1 == OkOf(ch) IN
      LET ch2 == ReceivedPotatoStartGame(ch1, StartGames) IN
      IF IsErr(ch2) THEN
        Err(p)
      ELSE
        Ok(DropTheirStartQueue(SetChannelHandler(p, OkOf(ch2))))
  ELSE IF Len(p.my_start_queue) > 0 THEN
    LET desc == FirstMyStartQueue(p) IN
    LET p2 == DropMyStartQueue(p) IN
    LET ch == ChannelHandler(p2) IN
    IF IsErr(ch) THEN
      Err(p2)
    ELSE
      Ok(SendMessage(p2, UIStartGames))
  ELSE
    Ok(p)

\* potato_handler/mod.rs:598
\* Return << -1..1, new_potato_handler >>
HavePotatoMove(p) ==
  IF Len(p.game_action_queue) > 0 THEN
    LET game_action == FirstGameActionQueue(p) IN
    LET p1 == DropGameActionQueue(p) IN
    IF game_action = Move \/ game_action = MoveError THEN
      LET ch == ChannelHandler(p1) IN
      IF IsErr(ch) THEN
        Err(p1)
      ELSE
        LET p2 == SendPotatoMove(p1, OkOf(ch), game_action) IN
        LET p3 == PotatoState(OkOf(p2), PotatoAbsent) IN
        Rv(1, p3)
    ELSE IF game_action = RedoMove THEN
      Err(p1)
    ELSE IF game_action = RedoAccept THEN
      Err(p1)
    ELSE IF game_action = Accept \/ game_action = AcceptError THEN
      LET ch == ChannelHandler(p1) IN
      IF IsErr(ch) THEN
        Err(p1)
      ELSE
        LET p2 == SendPotatoAccept(p1, OkOf(ch), game_action) IN
        IF IsErr(p2) THEN
          p2
        ELSE
          LET p3 == PotatoState(OkOf(p2), PotatoAbsent) IN
          Rv(1, p3)
    ELSE IF game_action = Shutdown \/ game_action = ShutdownError THEN
      LET ch == ChannelHandler(p1) IN
      IF IsErr(ch) THEN
        Err(p1)
      ELSE
        LET p2 == SendPotatoCleanShutdown(p1, OkOf(ch), game_action) IN
        LET p3 == SendMessage(OkOf(p2), game_action) IN
        Rv(1, NewState(p3, OnChainWaitingForUnrollSpend))
    ELSE IF game_action = UIStartGames THEN
      Rv(1, p1)
    ELSE IF game_action = RequestPotato THEN
      IF p1.have_potato = PotatoAbsent THEN
        Rv(1, SendMessage(p1, game_action))
      ELSE
        Rv(1, p1)
    ELSE IF game_action = SendPotato THEN
      LET ch == ChannelHandler(p1) IN
      IF IsErr(ch) THEN
        Err(p1)
      ELSE
        LET p2 == SendPotatoMove(p1, OkOf(ch), Nil) IN
        LET p3 == PotatoState(OkOf(p2), PotatoAbsent) IN
        Rv(1, p3)
    ELSE
      \* Illegal requested action
      Rv(1, NewState(p1, Error + game_action))
  ELSE
    Rv(0, p)

\* potato_handler/mod.rs:300
\* Internally updates information that isn't part of this model.
UpdateChannelCoinAfterReceive(p) ==
  LET p0 == PotatoState(p, PotatoPresent) IN
  LET p1 == HavePotatoStartGame(p0) IN
  IF IsErr(p1) THEN
    p1
  ELSE
    LET p2 == HavePotatoMove(OkOf(p1)) IN
    IF IsErr(p2) THEN
      p2
    ELSE
      LET ch == ChannelHandler(OkOf(p2)) IN
      IF IsErr(ch) THEN
        p2
      ELSE
        Ok(SetChannelHandler(OkOf(p2), OkOf(ch)))

\* potato_handler/mod.rs:346
PassOnChannelHandlerMessage(p0,msg) ==
  LET p == PotatoState(p0, PotatoPresent) IN
  LET ch == ChannelHandler(p) IN
  IF IsErr(ch) THEN
    Err(p)
  ELSE
    LET ch1 == OkOf(ch) IN
    IF msg = Nil \/ msg = NilError THEN
      LET ch2 == ReceivedEmptyPotato(ch1, msg) IN
      IF IsErr(ch2) THEN
        Err(p)
      ELSE
        LET p1 == SetChannelHandler(p, OkOf(ch2)) IN
        UpdateChannelCoinAfterReceive(p1)
    ELSE IF msg = StartGames \/ msg = StartGamesError THEN
      LET ch2 == ReceivedPotatoStartGame(ch1, msg) IN
      IF IsErr(ch2) THEN
        Err(p)
      ELSE
        LET p1 == SetChannelHandler(p, OkOf(ch)) IN
        UpdateChannelCoinAfterReceive(p1)
    ELSE IF msg = Move \/ msg = MoveError THEN
      LET ch2 == ReceivedPotatoMove(ch1, msg) IN
      IF IsErr(ch2) THEN
        Err(p)
      ELSE
        LET p1 == SetChannelHandler(p, OkOf(ch)) IN
        UpdateChannelCoinAfterReceive(p1)
    ELSE IF msg = Accept \/ msg = AcceptError THEN
      LET ch2 == ReceivedPotatoAccept(ch1, msg) IN
      IF IsErr(ch2) THEN
        Err(p)
      ELSE
        LET p1 == SetChannelHandler(p, OkOf(ch)) IN
        UpdateChannelCoinAfterReceive(p1)
    ELSE IF msg = Shutdown \/ msg = ShutdownError THEN
      LET ch2 == ReceivedPotatoCleanShutdown(ch1, msg) IN
      IF IsErr(ch2) THEN
        Err(p)
      ELSE
        Ok(NewState(SetChannelHandler(p, ChannelHandlerEnded), OnChainWaitingForUnrollSpend))
    ELSE
      Err(p)

TryCompleteStepE(p) ==
  IF p.handshake_state = PostStepE /\ p.channel_initiation_transaction > 0 THEN
    Ok(NewState(SendMessage(p,HandshakeE),Finished))
  ELSE
    Ok(p)

TryCompleteStepF(p) ==
  IF p.waiting_to_start > 0 THEN
    Ok(p)
  ELSE IF p.handshake_state = PostStepF /\ p.channel_transaction_completed > 0 THEN
    Ok(NewState(SendMessage(p,HandshakeF),Finished))
  ELSE
    Ok(p)

ChannelHandlerMessage(p,act) ==
  LET ch == ChannelHandler(p) IN
  IF IsErr(ch) THEN
    Err(p)
  ELSE
    LET ch1 == OkOf(ch) IN
    IF act = StartGamesError \/ act = MoveError \/ act = AcceptError \/ act = ShutdownError THEN
      Err(p)
    ELSE
      Ok(SendMessage(SetChannelHandler(p, ch1 + 1), act))

\* potato_handler/mod.rs:1481
SendPotatoRequestIfNeeded(p) ==
  IF p.have_potato = PotatoPresent THEN
    Rv(1, p)
  ELSE IF p.have_potato = PotatoAbsent THEN
    LET p1 == EnqueueGameAction(PotatoState(p, PotatoRequested), RequestPotato) IN
    Rv(0, p1)
  ELSE
    Rv(0, p)

\* potato_handler/mod.rs:1481
DoGameAction(p,act) ==
  IF p.handshake_state = Finished THEN
    IF act = SendPotato /\ p.have_potato = PotatoAbsent THEN
      Ok(p)
    ELSE
      LET p0 == EnqueueGameAction(p,act) IN
      LET p1 == SendPotatoRequestIfNeeded(p0) IN
      IF RvOf(p1) > 0 THEN
        HavePotatoMove(OkOf(p1))
      ELSE
        p1
  ELSE
    Err(p)

RehydrateGames(g) == g - UIStartGames + StartGames

\* potato_handler/mod.rs:836
ReceivedGameStart(p, g) ==
  IF Len(p.their_start_queue) = 0 THEN
    Err(p)
  ELSE
    LET ch == ChannelHandler(p) IN
    IF IsErr(ch) THEN
      Err(p)
    ELSE
      LET ch1 == OkOf(ch) IN
      LET ch2 == ReceivedPotatoStartGame(ch1, RehydrateGames(g)) IN
      IF IsErr(ch2) THEN
        Err(p)
      ELSE
        LET ch3 == OkOf(ch2) IN
        UpdateChannelCoinAfterReceive(SetChannelHandler(p, ch3))

\* potato_handler/mod.rs:874
ProcessIncomingMessage(p,m) ==
  IF p.handshake_state = StepB /\ m = HandshakeA THEN
    Ok(SendMessage(NewState(NewChannelHandler(p), StepD), HandshakeB))
  ELSE IF p.handshake_state = StepC /\ m = HandshakeB THEN
    Ok(SendMessage(NewState(AskForChannelInitTransaction(NewChannelHandler(p)), StepE), Nil))
  ELSE IF p.handshake_state = StepD THEN
    Ok(SendMessage(NewState(p, StepF), Nil))
  ELSE IF p.handshake_state = StepE THEN
    TryCompleteStepE(NewState(p, PostStepE))
  ELSE IF p.handshake_state = StepF THEN
    TryCompleteStepF(ReceivedChannelOffer(NewState(PotatoState(p, PotatoAbsent), PostStepF)))
  ELSE IF p.handshake_state # Finished /\ (m = UIStartGames \/ m = UIStartGamesError) THEN
    Ok(EnqueueGameAction(p, m))
  ELSE IF p.handshake_state = Finished THEN
    IF m = HandshakeF THEN
      Ok(p)
    ELSE IF m = RequestPotato THEN
      IF p.have_potato = PotatoPresent THEN
        DoGameAction(p, SendPotato)
      ELSE
        EnqueueGameAction(p, SendPotato)
    ELSE IF m = UIStartGames \/ m = UIStartGamesError THEN
      ReceivedGameStart(p, m)
    ELSE
      PassOnChannelHandlerMessage(p,m)
  ELSE
    LET HandshakeActions == SelectSeq(p.incoming_messages, LAMBDA x: x <= HandshakeF) IN
    LET NewQueue == SelectSeq(p.incoming_messages, LAMBDA x: x > HandshakeF) IN
    Ok([p EXCEPT !.incoming_messages = HandshakeActions \o << m >> \o NewQueue])    

\* potato_handler/mod.rs:1146
ReceivedMessage(p, msg) == Ok(AppendIncoming(p, msg))

ProcessQueueActions(p) ==
  IF Len(p.game_action_queue) > 0 THEN
    LET game_action == FirstGameActionQueue(p) IN
    LET p1 == DropGameActionQueue(p) IN
    LET p2 == DoGameAction(p1, game_action) IN
    IF IsErr(p2) THEN
      p2
    ELSE IF RvOf(p2) > 0 THEN
      ProcessQueueActions(OkOf(p2))
    ELSE
      p2
  ELSE
    Ok(p)

\* potato_handler/mod.rs:1160
HandleIncomingMessage(p) ==
  IF Len(p.incoming_messages) > 0 THEN
    LET m == p.incoming_messages[1] IN
    LET p2 == DropIncomingMessage(p) IN
    LET p3 == ProcessIncomingMessage(p2, m) IN
    IF IsErr(p3) THEN
      p3
    ELSE
      ProcessQueueActions(OkOf(p3))
  ELSE
    Ok(p)

\* potato_handler/mod.rs:1835
CoinCreated(p) ==
  IF p.handshake_state = PostStepF THEN
    LET p1 == [p EXCEPT !.channel_transaction_completed = 1, !.channel_transaction_sent = 2, !.waiting_to_start = 0] IN
    TryCompleteStepF(p1)
  ELSE
    Ok(p)

\* FromLocalUI

\* potato_handler/mod.rs:1704
FLUI_StartGames(p, i_initiated, s) ==
  IF i_initiated > 0 THEN
    IF p.handshake_state # Finished THEN
      p \* error
    ELSE
      LET p1 == AppendMyStartQueue(p, s) IN
      LET p2 == EnqueueGameAction(p, StartGames) IN
      LET p3 == SendPotatoRequestIfNeeded(p1) IN
      IF RvOf(p3) = 0 THEN
        OkOf(p3)
      ELSE
        OkOf(HavePotatoMove(OkOf(p3)))
  ELSE
    AppendTheirStartQueue(p, s)

FLUI_MakeMove(p, act) ==
  OkOf(DoGameAction(p, act))

FLUI_Accept(p, act) ==
  OkOf(DoGameAction(p, act))

FLUI_Shutdown(p, act) ==
  OkOf(DoGameAction(p, act))

StartA ==
  /\ a.handshake_state = StepA
  /\ a' = Start(a) /\ UNCHANGED << b, ui_actions >>

Active(p) == p.channel_handler < ChannelHandlerEnded

ReceivedMessageA ==
  /\ Active(a)
  /\ Len(b.messages) > 0
  /\ Len(a.incoming_messages) = 0
  /\ b' = DropMessage(b)
  /\ a' = OkOf(ReceivedMessage(a, FirstMessage(b)))
  /\ UNCHANGED << ui_actions >>

ReceivedMessageB ==
  /\ Active(b)
  /\ Len(a.messages) > 0
  /\ Len(b.incoming_messages) = 0
  /\ a' = DropMessage(a)
  /\ b' = OkOf(ReceivedMessage(b, FirstMessage(a)))
  /\ UNCHANGED << ui_actions >>

HandleInboundQueueA ==
  /\ Active(a)
  /\ Len(a.incoming_messages) > 0
  /\ a' = OkOf(HandleIncomingMessage(a))
  /\ UNCHANGED << b, ui_actions >>

HandleInboundQueueB ==
  /\ Active(b)
  /\ Len(b.incoming_messages) > 0
  /\ b' = OkOf(HandleIncomingMessage(b))
  /\ UNCHANGED << a, ui_actions >>

ChannelPuzzleHashA ==
  /\ a.channel_puzzle_hash = 1
  /\ a' = OkOf(TryCompleteStepE(ReplyChannelInitTransaction(a)))
  /\ UNCHANGED << b, ui_actions >>

ChannelPuzzleHashB ==
  /\ b.channel_puzzle_hash = 1
  /\ b' = OkOf(TryCompleteStepE(ReplyChannelInitTransaction(b)))
  /\ UNCHANGED << a, ui_actions >>

ChannelTransactionA ==
  /\ a.channel_transaction_sent = 1
  /\ a' = OkOf(CoinCreated(a))
  /\ UNCHANGED << b, ui_actions >>

ChannelTransactionB ==
  /\ b.channel_transaction_sent = 1
  /\ b' = OkOf(CoinCreated(b))
  /\ UNCHANGED << a, ui_actions >>

StartGamesA ==
  /\ ui_actions.sent_moves < 1
  /\ a.handshake_state >= Finished
  /\ a.handshake_state < MaxHandshakeState
  /\ a' = FLUI_StartGames(a, 1, StartGames)
  /\ b' = FLUI_StartGames(b, 0, StartGames)
  /\ ui_actions' = [ui_actions EXCEPT !.sent_moves = 1]

GameMoveA ==
  /\ ui_actions.sent_moves >= 1 
  /\ ui_actions.sent_moves < 7
  /\ a.handshake_state >= Finished
  /\ a.handshake_state < MaxHandshakeState
  /\ a' = FLUI_MakeMove(a, Move)
  /\ ui_actions' = [ui_actions EXCEPT !.sent_moves = ui_actions.sent_moves + 1]
  /\ UNCHANGED << b >>

GameMoveB ==
  /\ ui_actions.sent_moves >= 1 
  /\ ui_actions.sent_moves < 7
  /\ b.handshake_state >= Finished
  /\ b.handshake_state < MaxHandshakeState
  /\ b' = FLUI_MakeMove(b, Move)
  /\ ui_actions' = [ui_actions EXCEPT !.sent_moves = ui_actions.sent_moves + 1]
  /\ UNCHANGED << a >>

GameAcceptA ==
  /\ ui_actions.sent_moves = 7
  /\ a.handshake_state >= Finished
  /\ a.handshake_state < MaxHandshakeState
  /\ a' = FLUI_Accept(a, Accept)
  /\ ui_actions' = [ui_actions EXCEPT !.sent_moves = ui_actions.sent_moves + 1]
  /\ UNCHANGED << b >>

GameAcceptB ==
  /\ ui_actions.sent_moves = 8
  /\ b.handshake_state >= Finished
  /\ b.handshake_state < MaxHandshakeState
  /\ b' = FLUI_Accept(b, Accept)
  /\ ui_actions' = [ui_actions EXCEPT !.sent_moves = ui_actions.sent_moves + 1]
  /\ UNCHANGED << a >>

ShutdownA ==
  /\ ui_actions.sent_moves = 9
  /\ a.handshake_state >= Finished
  /\ a.handshake_state < MaxHandshakeState
  /\ a' = FLUI_Shutdown(a, Shutdown)
  /\ ui_actions' = [ui_actions EXCEPT !.sent_moves = ui_actions.sent_moves + 1]
  /\ UNCHANGED << b >>

ShutdownB ==
  /\ ui_actions.sent_moves = 10
  /\ b.handshake_state >= Finished
  /\ b.handshake_state < MaxHandshakeState
  /\ b' = FLUI_Shutdown(b, Shutdown)
  /\ ui_actions' = [ui_actions EXCEPT !.sent_moves = ui_actions.sent_moves + 1]
  /\ UNCHANGED << a >>

SideShutDown(p) ==
  /\ p.channel_handler >= ChannelHandlerEnded

BothShutDown == SideShutDown(a) /\ SideShutDown(b) /\ UNCHANGED allvars

Termination == <>(SideShutDown(a) /\ SideShutDown(b))

Next ==
  \/ StartA
  \/ ReceivedMessageA
  \/ ReceivedMessageB
  \/ HandleInboundQueueA
  \/ HandleInboundQueueB
  \/ ChannelPuzzleHashA
  \/ ChannelPuzzleHashB
  \/ ChannelTransactionA
  \/ ChannelTransactionB
  \/ StartGamesA
  \/ GameMoveA
  \/ GameMoveB
  \/ GameAcceptA
  \/ GameAcceptB
  \/ ShutdownA
  \/ ShutdownB
  \/ BothShutDown

Spec ==
  /\ Init
  /\ [][Next]_allvars

PHInvariant(p) ==
  /\ p.handshake_state >= StepA
  /\ p.handshake_state < MaxHandshakeState
  /\ p.have_potato >= PotatoAbsent
  /\ p.have_potato <= PotatoPresent
  /\ Len(p.messages) < 20
  /\ Len(p.incoming_messages) < 20
  /\ Len(p.game_action_queue) < 20

Inv ==
  /\ PHInvariant(a)
  /\ PHInvariant(b)

====

\end{verbatim}

\twocolumn
\section*{Acknowledgement}
We thank Dan Boneh for his advice, and Leslie Lamport for creating TLA+

\section*{Authors' Contributions}
All authors have participated in drafting the manuscript. All authors read and approved the final version of the manuscript.

\section*{Conflict of Interest}
The authors declare no conflict of interest.

\section*{Data Availability}
All code discussed is available at \href{https://github.com/Chia-Network/chia-gaming}{github.com/Chia-Network/chia-gaming}

\section*{Ethical Statement}
In this article, the principles of scientific research and publication ethics were followed. No AGIs were harmed (or used) in this research, or the creation of this document.

\begin{thebibliography}{8}
\bibitem{1} Poon, J., \& Dryja, T. (2016). The Bitcoin Lightning Network:
Scalable Off-Chain Instant Payments. \href{https://lightning.network/lightning-network-paper.pdf}{lightning.network/lightning-network-paper.pdf}

\bibitem{2} TLA+ Website \href{https://lamport.azurewebsites.net/tla/tla.html}{lamport.azurewebsites.net/tla/tla.html}

TODO: Refs for: State Channels, Bitcoin Script


\end{thebibliography}

\end{multicols}
\end{document}